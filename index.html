<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Doodle Line — STEP_RESET_v12-51e (C9↔G19 swap) — r3c-purge — r4-thumbs-standby — r9-ui</title>
  <style>
    :root{--accent:#80FF80;--fg:#000;--bg:#fff}
    html,body{margin:0;height:100%;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif}
    #wrap{position:fixed;inset:0}
    canvas{display:block;width:100%;height:100%;touch-action:none;cursor:crosshair}
    .toprule{position:fixed;left:0;right:0;top:0;height:1px;background:#000}
    .thumbbar{position:fixed;right:20px;top: 74px;z-index:905}
    .thumbgrid{display:grid;grid-template-columns:80px 80px 80px;column-gap:10px;row-gap:18px}
    .thumb{width:80px;height:80px;border:1px solid #000;border-radius:50%;background:#fff;position:relative;cursor:pointer;overflow:hidden}
    .thumb.active{outline:4px solid var(--accent)}
    .thumb{background-repeat:no-repeat;background-position:50% 50%;background-size:cover}
    .thumb .label{position:absolute;left:0;right:0;bottom:2px;text-align:center;font-size:11px;color:#000;background:rgba(255,255,255,.7)}
    canvas.overlay{position:fixed;inset:0;display:block;width:100%;height:100%;touch-action:none;pointer-events:none;z-index:1}
    .sidebtn{position:fixed;right:302px;width:80px;height:80px;border:1px solid #000;border-radius:50%;background:#fff;display:flex;align-items:center;justify-content:center;cursor:pointer}
    .sidebtn span{display:inline-block;text-align:center;line-height:1.3;font-size:14px}
    .sidebtn.clear span{line-height:1.45}
    .sidebtn.eraser span{line-height:1.45}
    .sidebtn.save span{line-height:1.45}
    .sidebtn.active{background:#80FF80}
    .sidebtn.pressed{background:#80FF80}
    .sidebtn[disabled]{opacity:.4;cursor:default}
    .sidebtn.back{top:355px}
    .sidebtn.clear{top:453px}
    .sidebtn.save{top:551px}
    .pill{position:fixed;right:23px;top:12px;font:400 17px "Yu Gothic UI","Yu Gothic","Meiryo",sans-serif}
    .tagline{position:fixed;right:22px;top:36px;font-weight:400;letter-spacing:.04em;color:#000}
    .tagline span{display:inline-block;margin-left:1px}
    .tagline .wig{animation:none}
    body{min-height:calc(100vh + 180px);}
    
    .save-link{position:fixed; right:22px;
      background:none; border:0; padding:0; margin:0;
      font:400 14px "Yu Gothic UI","Yu Gothic","Meiryo",sans-serif;
      color:#000; text-decoration:underline; cursor:pointer; z-index:905;}

    .microfoot{position:absolute; left:0; right:0; top:calc(100vh + 72px); z-index:1001; padding:6px 10px; text-align:center; font-size:12px; letter-spacing:.02em; color:#000; pointer-events:none;}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c"></canvas>
    <canvas id="ov" class="overlay" aria-hidden="true"></canvas>

    <div class="thumbbar" id="thumbbar">
      <div class="thumbgrid" id="thumbgrid"></div>
    </div>

    <button class="sidebtn eraser" id="eraserBtn"><span>Erase<br>けす</span></button>
    <button class="sidebtn back" id="backBtn"><span>Back<br>ひとつ<br>もどる</span></button>
    <button class="sidebtn clear" id="clearBtn"><span>Clear<br>クリア</span></button>
    <button id="saveLink" class="save-link" type="button" aria-label="らきがきをダウンロード">らきがきをダウンロード</button>

    <div class="pill" aria-hidden="true">Doodle Line</div>
    <div class="tagline" id="tagline" aria-label="かいてあそぼう"><span>か</span><span>い</span><span>て</span><span class="wig">あ</span><span>そ</span><span>ぼ</span><span>う</span></div>
    <div class="toprule" aria-hidden="true"></div>
  </div>
  <footer class="microfoot" id="microfoot">© Doodle Line — Code as Touch prototype by nami</footer>

  <script>
  document.addEventListener('DOMContentLoaded', function(){'use strict';
  try{ console.info('[DoodleLine] r9-ui labels removed / JA copy updated'); }catch(_){ }

  try{ console.info('[DoodleLine] v12-51e.r4-thumbs-standby loaded'); }catch(_){ }

  try{ console.info('[DoodleLine] v12-51e.r3c-purge loaded'); }catch(_){ }

    // 固定 Seat -> Brush（RESET v11-6c）
    const seatOrder = ["A1", "A2", "A3", "B4", "B5", "B6", "C7", "C8", "C9", "D10", "D11", "D12", "E13", "E14", "E15", "F16", "F17", "F18", "G19", "G20", "G21"];
    const FIXED_SEAT_TO_BRUSH = {
  "A1": "brush.basicThin",
  "A2": "brush.basicJitter2",
  "A3": "brush.dashA3",
  "B4": "brush.facetA3",
  "B5": "brush.straightE13",
  "B6": "brush.fillGrayB6",
  "C7": "brush.debrisF17",
  "C8": "brush.sprinklesF18",
  "C9": "brush.sprayBlackF16",
  "D10": "brush.hatchD10min",
  "D11": "brush.flatD10",
  "D12": null,
  "E13": "brush.bandRim",
  "E14": "brush.band@E14",
  "E15": "brush.bandCenter",
  "F16": "brush.redDotsC7",
  "F17": "brush.circlesVarC8",
  "F18": "brush.bigDotsC9",
  "G19": "brush.snowSquaresC9",
  "G20": null,
  "G21": null};

    function baseOf(id){ if(!id) return id; return id.replace(/@.*/, ''); }

    // ブラシレジストリ（A3/D10 minimal, others retained）
    const BRUSHES=(function(){ 
      const B={color:'#000',width:{min:1,max:1},spacingPx:1};
      function p(o){return JSON.parse(JSON.stringify(o));}
      return {
        'brush.empty':{params:{}},
        'brush.basicThin':      {params:{...p(B), width:{min:0.5,max:0.5}, spacingPx:0.5}},
        'brush.basicJitter2':   {params:{...p(B), width:{min:2,max:2}, spacingPx:1}},
        'brush.facetA3':        {params:{...p(B), width:{min:4,max:4}, facet:true, facets:12, facetStep:10}},
        'brush.straightE13':    {params:{...p(B), width:{min:1,max:1}}},
        'brush.fillGrayB6':     {params:{...p(B), width:{min:28,max:28}}},
        'brush.debrisF17':      {params:{...p(B), width:{min:1,max:1}}},
        'brush.sprinklesF18':   {params:{...p(B), width:{min:40,max:40}, sprinkles:{lenMin:4,lenMax:24}, spacingPx:1}},
        'brush.flatD10':        {params:{...p(B), width:{min:10,max:10}}},
        'brush.band':           {params:{...p(B), width:{min:24,max:24}, band:{alphas:[0.15,0.35,0.6,0.95]}}},
        'brush.band@E14':       {params:{...p(B), width:{min:24,max:24}, band:{alphas:[0.15,0.35,0.6,0.95]}}},
        'brush.bandCenter':     {params:{...p(B), width:{min:28,max:28}, band:{alphas:[0.50,0.27,0.24,0.14]}}},
        'brush.redDotsC7':      {params:{...p(B), width:{min:10,max:10}}},
        'brush.circlesVarC8':   {params:{...p(B), width:{min:1,max:1}, circlesVar:{bBase:12,basePitch:56,speedGainPitch:1.25,speedCurve:2.0,speedCalib:1.6,strokeChoices:[ 1, 3.2, 6.4, 12.8 ]}}},
        'brush.bigDotsC9':      {params:{...p(B), width:{min:1,max:1}, bigdots:{radiusPx:40,strokeWidth:1,basePitch:144,speedGain:2.0,speedCurve:2.4,speedCalib:1.6}}},
        'brush.sprayBlackF16':  {params:{...p(B), width:{min:40,max:40}}},
        'brush.bandRim':        {params:{...p(B), width:{min:24,max:24}, rim:{rimWidthPx:2, outerAlpha:0.35}}},
        'brush.snowSquaresC9':  {params:{...p(B), width:{min:1,max:1}, snow:{dot:8}}},
        // ★ 新規：A3 minimal dashed
        'brush.dashA3': { params:{...p(B), width:{min:1.2,max:1.2}, dash:{
          Lmin:6, Lmax:22, Pmin:30, Pmax:72, marginHead:10, marginTail:10, calibV:1600
        }}},
        // ★ 新規：D10 minimal hatch
        'brush.hatchD10min': { params:{...p(B), width:{min:1,max:1}, hatch:{
          angle: Math.PI/4, Lmin:6, Lmax:18, Pmin:16, Pmax:36, offsetN:6, calibV:1600
        }}},
'brush.vStripesD12': { params:{...p(B), width:{min:1,max:1}, vstripes:{ lenMin:12, lenMax:48, pitch:30 }}},
'brush.crossScatterG20': { params:{...p(B), width:{min:1,max:1}, cross:{ size:8, minGap:12 }}},
'brush.randSegG21': { params:{...p(B), width:{min:1,max:1}, rseg:{ pitch:40, lenScale:3.6, fracMin:0.5, fracMax:0.6667, stepMul:0.35 }}}
};
    })();

    // === SELF-CHECK（BRUSHES 初期化後）===
    (function __selfcheck__(){
      try{
        const seats = Object.keys(FIXED_SEAT_TO_BRUSH);
        const missingBrush = [];
        const moveKnown = new Set(['brush.empty','brush.basicThin','brush.basicJitter2','brush.facetA3','brush.bandRim','brush.band','brush.bandCenter','brush.redDotsC7','brush.circlesVarC8','brush.bigDotsC9','brush.flatD10','brush.segOutlineD12','brush.straightE13','brush.diagHatchD11','brush.sprayBlackF16','brush.debrisF17','brush.sprinklesF18','brush.fillGrayB6','brush.snowSquaresC9','brush.dashA3','brush.hatchD10min']);
        const missRoute = [];
        seats.forEach(seat=>{
          const id = FIXED_SEAT_TO_BRUSH[seat];
          if(id==null) return;
          if(!BRUSHES[id]) missingBrush.push({seat, id});
          const base = baseOf(id);
          if(!moveKnown.has(base)) missRoute.push({seat, id, base});
        });
        if(missingBrush.length){ console.warn('[DoodleLine:selfcheck] BRUSH id not found:', missingBrush); }
        if(missRoute.length){ console.warn('[DoodleLine:selfcheck] Unknown route (base id not in switch):', missRoute); }
      }catch(e){ console.warn('[DoodleLine:selfcheck] skipped:', e); }
    })();

    // 画面初期化・UI
    const cvs=document.getElementById('c'); const ctx=cvs.getContext('2d');
    const ov=document.getElementById('ov'); const ovctx=ov.getContext('2d');
    let dpr=Math.max(1, window.devicePixelRatio||1);

    // === Canvas baseline ===
    function resetStrokeState(g){
      g.globalCompositeOperation='source-over';
      try{ g.setLineDash([]);}catch(e){}
      g.lineJoin='round'; g.lineCap='round'; g.globalAlpha=1;
    }
    function fillWhite(){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); resetStrokeState(ctx); ctx.fillStyle='#fff'; ctx.fillRect(0,0,cvs.width,cvs.height); ctx.restore(); }
    function clearOverlay(){ ovctx.save(); ovctx.setTransform(dpr,0,0,dpr,0,0); resetStrokeState(ovctx); ovctx.clearRect(0,0,ov.width,ov.height); ovctx.restore(); }

    const UNDO_MAX=20; const undoStack=[];
    function updateBackEnabled(){ const b=document.getElementById('backBtn'); if(b) b.disabled=(undoStack.length===0); }
    function _makeSnapshot(){ try{ const off=document.createElement('canvas'); off.width=cvs.width; off.height=cvs.height; const g=off.getContext('2d'); g.setTransform(1,0,0,1,0,0); g.drawImage(cvs,0,0); return off; } catch(e){ return null; } }
    function pushSnapshot(){ const s=_makeSnapshot(); if(!s) return; undoStack.push(s); if(undoStack.length>UNDO_MAX) undoStack.shift(); updateBackEnabled(); }
    function restoreSnapshot(){ if(!undoStack.length) return; const s=undoStack.pop(); ctx.save(); ctx.setTransform(1,0,0,1,0,0); resetStrokeState(ctx); ctx.clearRect(0,0,cvs.width,cvs.height); ctx.drawImage(s,0,0); ctx.restore(); updateBackEnabled(); }

    function resize(){
      dpr=Math.max(1, window.devicePixelRatio||1);
      const HARD_MAX=12288;
      const cssW=window.innerWidth, cssH=window.innerHeight;
      const maxCssW=Math.min(cssW, Math.floor(HARD_MAX/dpr));
      const maxCssH=Math.min(cssH, Math.floor(HARD_MAX/dpr));
      cvs.style.width=maxCssW+'px'; cvs.style.height=maxCssH+'px';
      cvs.width=Math.floor(maxCssW*dpr); cvs.height=Math.floor(maxCssH*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ov.style.width=cvs.style.width; ov.style.height=cvs.style.height;
      ov.width=cvs.width; ov.height=cvs.height;
      ovctx.setTransform(dpr,0,0,dpr,0,0); clearOverlay();
      fillWhite(); undoStack.length=0; updateBackEnabled(); layoutThumbbar();
    }
    addEventListener('resize', resize, {passive:true}); resize();

    function layoutThumbbar(){ const tb=document.getElementById('thumbbar'); if(tb) tb.style.top=' 74px'; positionSideButtons(); }
    function positionSideButtons(){
      const tb=document.getElementById('thumbbar');
      const er=document.getElementById('eraserBtn'); const back=document.getElementById('backBtn'); const clear=document.getElementById('clearBtn'); const saveLink=document.getElementById('saveLink');
      if(!tb) return;
      const tbTop=parseInt(getComputedStyle(tb).top,10)||70;
      const H=80, G=18;
      const centerC=tbTop + 2*(H+G) + H/2;
      const centerD=tbTop + 3*(H+G) + H/2;
      const centerE=tbTop + 4*(H+G) + H/2;
      if(er)    er.style.top=Math.round(centerC - H/2)+'px';
      if(back)  back.style.top=Math.round(centerD - H/2)+'px';
      if(clear) clear.style.top=Math.round(centerE - H/2)+'px';
      if(saveLink){ const y = tbTop + 7*(H+G) + 6; saveLink.style.top = Math.round(y)+'px'; }
    }
    function updateTaglineSizes(){ const tg=document.getElementById('tagline'); if(!tg) return; const spans=tg.querySelectorAll('span'); for(let i=0;i<spans.length;i++){ const base=12, max=18; const sz=Math.round(base + Math.random()*(max-base)); spans[i].style.fontSize=sz+'px'; } }

    // 消しゴム
    let __eraserActive=false;
    function setEraserActive(v){ __eraserActive=!!v; try{ const b=document.getElementById('eraserBtn'); if(b){ b.innerHTML = (__eraserActive? '<span>Doodle<br>かく</span>' : '<span>Erase<br>けす</span>'); } }catch(_ ){} try{ document.getElementById('eraserBtn').classList.toggle('active', __eraserActive); }catch(_ ){} }
    function eraseSegment(a,b){
      if(!a||!b) return;
      ctx.save();
      resetStrokeState(ctx);
      ctx.globalCompositeOperation='source-over';
      ctx.lineJoin='round'; ctx.lineCap='round';
      const W=24;
      ctx.lineWidth=W;
      ctx.strokeStyle='#fff';
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      ctx.restore();
    }

    // Seat/Brush
    let activeSeatIdx=0;
    const seatToBrush = Object.assign({}, FIXED_SEAT_TO_BRUSH);
    try{ seatToBrush['G20']=null; seatToBrush['G21']=null; }catch(_){ }
    
    // Override seats（D12=×散布, G20=縦ストライプ, G21=ランダム線分）
    try{ seatToBrush['D12']='brush.crossScatterG20'; }catch(_){}
    try{ seatToBrush['G20']='brush.vStripesD12'; }catch(_){}
    try{ seatToBrush['G21']='brush.randSegG21'; }catch(_){}
function currentSeat(){ return seatOrder[activeSeatIdx]; }
    function currentBrushId(){ const id = seatToBrush[currentSeat()]; return id || 'brush.empty'; }
    function currentCfg(){ const id=currentBrushId(); return BRUSHES[id]?.params || null; }

    function ensureBrushState(cfg){ if(!cfg) return; if(!cfg._state) cfg._state={ bigDotsCenters:[], occSnow:new Map(), snowPhase:0, snowDistAcc:0, snowTotal:0, snowP:0.48, bigDotsDist:0, spraySide:1, hatchResid:0, hatchAlt:0, segOut:{remain:0,alt:0,acc:0} }; }

    let __lastSeatSelectAt = 0;

    function setActiveSeat(seatIdx){
      activeSeatIdx=seatIdx;
      const nodes=[...document.querySelectorAll('.thumb')];
      nodes.forEach(n=>n.classList.remove('active'));
      const t=nodes[activeSeatIdx]; if(t) t.classList.add('active');
      setEraserActive(false);
      __lastSeatSelectAt = performance.now();
      resetStrokeState(ctx);
      clearOverlay();
    }

    // サムネ
    const __thumbCache=new Map();
    function renderThumbForBrush(brushId){
      const base=baseOf(brushId||'brush.empty');
      const key=base+'@v8';
      if(__thumbCache.has(key)) return __thumbCache.get(key);
      const W=72,H=72,pad=10;
      const off=document.createElement('canvas'); off.width=W; off.height=H;
      const g=off.getContext('2d'); g.fillStyle='#fff'; g.fillRect(0,0,W,H); g.strokeStyle='#000'; g.fillStyle='#000'; g.lineWidth=2;
      function line(x0,y0,x1,y1,w){ g.save(); g.lineWidth=w||2; g.beginPath(); g.moveTo(x0,y0); g.lineTo(x1,y1); g.stroke(); g.restore(); }
      function dots(n){ for(let k=0;k<n;k++){ const x=pad+Math.random()*(W-2*pad), y=pad+Math.random()*(H-2*pad); const r=1+Math.random()*2; g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill(); } }
      function squaresStroke(n,sz){ for(let k=0;k<n;k++){ const x=Math.round(pad+Math.random()*(W-2*pad-sz)); const y=Math.round(pad+Math.random()*(H-2*pad-sz)); g.strokeRect(x+0.5,y+0.5,sz-1,sz-1);}}
      switch(base){
        case 'brush.empty':
          g.strokeStyle='#aaa'; g.lineWidth=1.2;
          for(let i=-H;i<H;i+=8){ g.beginPath(); g.moveTo(0,i+H/2); g.lineTo(W,i+H/2+W); g.stroke(); }
          break;
        case 'brush.facetA3': line(pad,H-pad,W-pad,pad,2); break;
        case 'brush.bandRim': line(pad,H-pad,W-pad,pad,8); g.clearRect(W/2-10,H/2-3,20,6); break;
        case 'brush.band': case 'brush.bandCenter': line(pad,H-pad,W-pad,pad,10); break;
        case 'brush.flatD10': line(pad,H/2,W-pad,H/2,12); break;
        case 'brush.segOutlineD12': for(let y=pad;y<H-pad;y+=10){ line(pad+4,y,W-pad-4,y,2); } break;
        case 'brush.straightE13': line(pad,H-pad,W-pad,pad,2); break;
        case 'brush.diagHatchD11': for(let y=pad;y<H-pad;y+=12){ line(pad,y,W-pad,y,2); } break;
        case 'brush.sprayBlackF16': dots(10); break;
        case 'brush.debrisF17': dots(8); break;
        case 'brush.sprinklesF18': dots(6); break;
        case 'brush.fillGrayB6': g.fillStyle='#EAEAEA'; g.fillRect(pad+18,pad+18, W-2*(pad+18), H-2*(pad+18)); break;
        case 'brush.bigDotsC9': for(let y=pad; y<H-pad; y+=15){ line(pad+10,y,pad+26,y,4); } break;
        case 'brush.snowSquaresC9': squaresStroke(8,8); break;
        case 'brush.dashA3':
          g.lineCap='butt';
          for(let s=pad; s<W-pad; s+=14){ line(pad, H-pad, pad+Math.min(W-2*pad, s+8), H-pad, 2); }
          break;
        case 'brush.hatchD10min':
          g.lineCap='butt';
          for(let y=pad; y<H-pad; y+=10){ line(pad,y,pad+16,y-16,1); }
          break;
        default: dots(8); break;
      }
      const url=off.toDataURL(); __thumbCache.set(key,url); return url;
    }

    function attachSeatHandlers(btn, seatIdx){
      const activate = function(e){ try{ e && e.preventDefault && e.preventDefault(); }catch(_ ){} setActiveSeat(seatIdx); };
      btn.addEventListener('pointerdown', activate, {passive:false});
      btn.addEventListener('mousedown', activate, {passive:false});
      btn.addEventListener('touchstart', activate, {passive:false});
      btn.addEventListener('click', activate, {passive:false});
    }

  /* == inline thumbs (SVG) == */
  const THUMBS_SVG = {
  'A1': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBzdHJva2U6ICMwMDA7CiAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOwogICAgICAgIHN0cm9rZS13aWR0aDogMTBweDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGxpbmUgY2xhc3M9ImNscy0yIiB4MT0iMTYwIiB5MT0iNDAwIiB4Mj0iNjQwIiB5Mj0iNDAwIi8+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgo8L3N2Zz4=',
  'A2': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBzdHJva2U6ICMwMDA7CiAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOwogICAgICAgIHN0cm9rZS13aWR0aDogMjBweDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGxpbmUgY2xhc3M9ImNscy0yIiB4MT0iMTYwIiB5MT0iNDAwIiB4Mj0iNjQwIiB5Mj0iNDAwIi8+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgo8L3N2Zz4=',
  'A3': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBzdHJva2U6ICMwMDA7CiAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOwogICAgICAgIHN0cm9rZS13aWR0aDogMTZweDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGc+CiAgICA8bGluZSBjbGFzcz0iY2xzLTIiIHgxPSIxNjAiIHkxPSI0MDAiIHgyPSIxOTIiIHkyPSI0MDAiLz4KICAgIDxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjIzMiIgeTE9IjQwMCIgeDI9IjI5NiIgeTI9IjQwMCIvPgogICAgPGxpbmUgY2xhc3M9ImNscy0yIiB4MT0iNjQwIiB5MT0iNDAwIiB4Mj0iNjA4IiB5Mj0iNDAwIi8+CiAgICA8bGluZSBjbGFzcz0iY2xzLTIiIHgxPSI1NjgiIHkxPSI0MDAiIHgyPSI1MDQiIHkyPSI0MDAiLz4KICAgIDxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjM1MiIgeTE9IjQwMCIgeDI9IjQ0OCIgeTI9IjQwMCIvPgogIDwvZz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMSIgY3g9IjQwMCIgY3k9IjQwMCIgcj0iNDAwIi8+Cjwvc3ZnPg==',
  'B4': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBzdHJva2U6ICMwMDA7CiAgICAgICAgc3Ryb2tlLWxpbmVqb2luOiBiZXZlbDsKICAgICAgICBzdHJva2Utd2lkdGg6IDI0cHg7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxwb2x5Z29uIGNsYXNzPSJjbHMtMiIgcG9pbnRzPSI1NTcuMjEgNTY0IDMxNC43MiAxNDQgNDY1LjA1IDIzMC43OSAyNTcuMjEgNTkwLjc5IDMzNy41OSA2MzcuMjEgNDMwLjQxIDYzNy4yMSA1NTcuMjEgNTY0Ii8+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgo8L3N2Zz4=',
  'B5': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBmaWxsLXJ1bGU6IGV2ZW5vZGQ7CiAgICAgICAgc3Ryb2tlOiAjMDAwOwogICAgICAgIHN0cm9rZS1taXRlcmxpbWl0OiAxMDsKICAgICAgICBzdHJva2Utd2lkdGg6IDEycHg7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTU2Ni4zNCw1NjUuMTJjLTEyMC4wMiwxMTkuNjItMzc0LjE5LTI5LjEyLTM3NC4xOS0yOS4xMmwyMDcuODUtMzYwczI3MC44MSwyODUsMTY2LjM0LDM4OS4xMloiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMSIgY3g9IjQwMCIgY3k9IjQwMCIgcj0iNDAwIi8+Cjwvc3ZnPg==',
  'B6': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6IG5vbmU7CiAgICAgIH0KCiAgICAgIC5jbHMtMSwgLmNscy0yIHsKICAgICAgICBzdHJva2Utd2lkdGg6IDBweDsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBmaWxsOiAjZDBkMGQwOwogICAgICAgIGZpbGwtcnVsZTogZXZlbm9kZDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNTY2LjM0LDU2NS4xMmMtMTIwLjAyLDExOS42Mi0zNzQuMTktMjkuMTItMzc0LjE5LTI5LjEybDIwNy44NS0zNjBzMjcwLjgxLDI4NSwxNjYuMzQsMzg5LjEyWiIvPgogIDxjaXJjbGUgY2xhc3M9ImNscy0xIiBjeD0iNDAwIiBjeT0iNDAwIiByPSI0MDAiLz4KPC9zdmc+',
  'C7': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0idGV4dCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA4MDAgODAwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiBub25lOwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgc3Ryb2tlLXdpZHRoOiAwcHg7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogIzAwMDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgogIDxnPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzgzLjkxLDI3MC44NWMtMi40My0xMy44Mi05LjYtMjAuOTktMjAuODYtMjAuOTktMTQuNzIsMC0yNC45NiwxMi44LTI0Ljk2LDM4LjE1czEwLjUsMzguMTUsMjQuOTYsMzguMTVjMTEuOSwwLDE5LjA3LTYuNzgsMjEuODktMjEuMjVsMTYuMjYsNC45OWMtNS4yNSwyMC40OC0xOC4wNSwyOS41Ny0zOC4yNywyOS41Ny0yNS43MywwLTQzLjE0LTE4LjU2LTQzLjE0LTUxLjMzczE3LjU0LTUxLjU5LDQzLjE0LTUxLjU5YzIwLjM1LDAsMzMuNjcsMTEuMzksMzcuNzYsMzAuMjFsLTE2Ljc3LDQuMVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQ3MS4yLDI1MS4zOWMtMTYuMjYsMjYuMjQtMjQuMTksNTEuODQtMjYuNSw4Ni4yOGgtMTguMDVjMi44Mi0zNC4xOCwxMy40NC01OS41MiwyOS4wNi04NC42MWgtNDMuOTF2LTEzLjA2aDU5LjM5djExLjM5WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMjM0LjY2LDU0NS42NmgtMTUuNDl2LTkuNzNjLTQuNjEsNy44MS0xMS4zOSwxMS41Mi0xOS43MSwxMS41Mi0xNS4xLDAtMjYuODgtMTMuMTgtMjYuODgtMzcuMjVzMTIuMDMtMzYuMjMsMjYuODgtMzYuMjNjNy44MSwwLDE0Ljk4LDMuOTcsMTkuMiwxMS4xNHYtNDAuNThoMTZ2MTAxLjEyWk0yMTguNjYsNDk4LjU2Yy0zLjMzLTguMTktOC44My0xMi4wMy0xNC41OS0xMi4wMy04LjA2LDAtMTQuOTgsNy4zLTE0Ljk4LDIzLjk0czYuOTEsMjQuNDUsMTUuMzYsMjQuNDVjNS44OSwwLDExLjAxLTQuMzUsMTQuMjEtMTEuNzh2LTI0LjU4WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzEzLjc2LDU0NS42NmgtMTUuNjJ2LTEyLjE2Yy00Ljk5LDguNDUtMTMuNDQsMTMuOTUtMjIuNzksMTMuOTUtMTEuMzksMC0yMC4zNS02LjkxLTIwLjM1LTIwLjc0di01MS4zM2gxNi41MXY0Ni43MmMwLDcuOTQsMy41OCwxMS41Miw5Ljg2LDExLjUyczEyLjY3LTUuMTIsMTYuMjYtMTIuMDN2LTQ2LjIxaDE2LjEzdjcwLjI3WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzQ5Ljg2LDQ4Ny42OGM1LjUtOC40NSwxMy4wNi0xMy44MiwyMi4xNS0xMy44MnMxNS40OSw1LjUsMTcuMjgsMTMuN2M1LjUtOC4zMiwxMy4xOC0xMy43LDIyLjI3LTEzLjcsMTEuMzksMCwxOS4yLDcuNTUsMTkuMiwyMS4xMnY1MC42OWgtMTYuMTN2LTQ2LjIxYzAtNy45NC0zLjQ2LTExLjc4LTkuNzMtMTEuNzgtNS41LDAtMTEuMzksNC44Ni0xNC43MiwxMS45djQ2LjA4aC0xNS44N3YtNDYuMjFjMC04LjA2LTMuMDctMTEuNzgtOC43LTExLjc4cy0xMS42NSw0Ljc0LTE1LjIzLDExLjl2NDYuMDhoLTE1Ljg3di03MC4yN2gxNS4zNnYxMi4yOVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQ2Ni40Nyw0ODcuNjhjNS41LTguNDUsMTMuMDYtMTMuODIsMjIuMTUtMTMuODJzMTUuNDksNS41LDE3LjI4LDEzLjdjNS41LTguMzIsMTMuMTgtMTMuNywyMi4yNy0xMy43LDExLjM5LDAsMTkuMiw3LjU1LDE5LjIsMjEuMTJ2NTAuNjloLTE2LjEzdi00Ni4yMWMwLTcuOTQtMy40Ni0xMS43OC05LjczLTExLjc4LTUuNSwwLTExLjM5LDQuODYtMTQuNzIsMTEuOXY0Ni4wOGgtMTUuODd2LTQ2LjIxYzAtOC4wNi0zLjA3LTExLjc4LTguNy0xMS43OHMtMTEuNjUsNC43NC0xNS4yMywxMS45djQ2LjA4aC0xNS44N3YtNzAuMjdoMTUuMzZ2MTIuMjlaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik01OTguMTgsNTQ4LjIyYy01LjUsMTYuMTMtMTMuOTUsMjIuMTUtMjguMjksMjIuMTUtMi42OSwwLTUuMzgtLjEzLTguNy0uNjRsLS42NC0xMi4yOWMzLjQ2LjY0LDYuMTQuOSw4Ljk2LjksNi41MywwLDEwLjg4LTMuNDYsMTMuMzEtMTAuODhsMS4wMi0zLjA3LTIzLjgxLTY5aDE3LjAybDguMzIsMjkuNDRjMi4zLDguMDYsMy44NCwxNC44NSw1Ljg5LDIzLjA0aDEuMjhjMi4xOC03Ljk0LDMuOTctMTUuMSw2LjI3LTIzLjNsOC4wNi0yOS4xOWgxNmwtMjQuNzEsNzIuODNaIi8+CiAgPC9nPgo8L3N2Zz4=',
  'C8': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0idGV4dCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA4MDAgODAwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiBub25lOwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgc3Ryb2tlLXdpZHRoOiAwcHg7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogIzAwMDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgogIDxnPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzgzLjkxLDI3MC44NWMtMi40My0xMy44Mi05LjYtMjAuOTktMjAuODYtMjAuOTktMTQuNzIsMC0yNC45NiwxMi44LTI0Ljk2LDM4LjE1czEwLjUsMzguMTUsMjQuOTYsMzguMTVjMTEuOSwwLDE5LjA3LTYuNzgsMjEuODktMjEuMjVsMTYuMjYsNC45OWMtNS4yNSwyMC40OC0xOC4wNSwyOS41Ny0zOC4yNywyOS41Ny0yNS43MywwLTQzLjE0LTE4LjU2LTQzLjE0LTUxLjMzczE3LjU0LTUxLjU5LDQzLjE0LTUxLjU5YzIwLjM1LDAsMzMuNjcsMTEuMzksMzcuNzYsMzAuMjFsLTE2Ljc3LDQuMVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQ3My41MSwzMTIuMzJjMCwxNi4yNi0xMi40MiwyNy4xNC0zMS40OSwyNy4xNHMtMzEuNjItMTAuMTEtMzEuNjItMjYuNjJjMC0xMS4yNiw1Ljg5LTE3LjkyLDE4Ljk0LTI0LjMyLTEyLjE2LTYuMjctMTYuNjQtMTQuMDgtMTYuNjQtMjQuOTYsMC0xNC4wOCwxMS42NS0yNS4yMiwyOS4xOS0yNS4yMnMyOS40NCwxMC4yNCwyOS40NCwyNC43MWMwLDEwLjUtNS42MywxNy41NC0xNy4xNSwyMi4yNywxNC4wOCw2LjY2LDE5LjMzLDE0LjM0LDE5LjMzLDI3LjAxWk00MzkuMDcsMjkzLjM3Yy05LjA5LDQuOTktMTMuNDQsMTAuMjQtMTMuNDQsMTguNDMsMCw5LjQ3LDYuMjcsMTUuODcsMTYuMjYsMTUuODdzMTYuMzgtNS42MywxNi4zOC0xNC44NWMwLTcuNjgtMy43MS0xMi4wMy0xNS40OS0xNy42N2wtMy43MS0xLjc5Wk00NDQuNzEsMjgwLjdjOC41OC00LjQ4LDExLjUyLTkuNDcsMTEuNTItMTcuMDIsMC04LjMyLTYuMTQtMTMuNTctMTQuMzQtMTMuNTdzLTE0LjA4LDQuOTktMTQuMDgsMTMuMzFjMCw2LjY2LDMuMiwxMC44OCwxMy4zMSwxNS42MmwzLjU4LDEuNjZaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0yMzQuNjYsNTQ1LjY2aC0xNS40OXYtOS43M2MtNC42MSw3LjgxLTExLjM5LDExLjUyLTE5LjcxLDExLjUyLTE1LjEsMC0yNi44OC0xMy4xOC0yNi44OC0zNy4yNXMxMi4wMy0zNi4yMywyNi44OC0zNi4yM2M3LjgxLDAsMTQuOTgsMy45NywxOS4yLDExLjE0di00MC41OGgxNnYxMDEuMTJaTTIxOC42Niw0OTguNTZjLTMuMzMtOC4xOS04LjgzLTEyLjAzLTE0LjU5LTEyLjAzLTguMDYsMC0xNC45OCw3LjMtMTQuOTgsMjMuOTRzNi45MSwyNC40NSwxNS4zNiwyNC40NWM1Ljg5LDAsMTEuMDEtNC4zNSwxNC4yMS0xMS43OHYtMjQuNThaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0zMTMuNzYsNTQ1LjY2aC0xNS42MnYtMTIuMTZjLTQuOTksOC40NS0xMy40NCwxMy45NS0yMi43OSwxMy45NS0xMS4zOSwwLTIwLjM1LTYuOTEtMjAuMzUtMjAuNzR2LTUxLjMzaDE2LjUxdjQ2LjcyYzAsNy45NCwzLjU4LDExLjUyLDkuODYsMTEuNTJzMTIuNjctNS4xMiwxNi4yNi0xMi4wM3YtNDYuMjFoMTYuMTN2NzAuMjdaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0zNDkuODYsNDg3LjY4YzUuNS04LjQ1LDEzLjA2LTEzLjgyLDIyLjE1LTEzLjgyczE1LjQ5LDUuNSwxNy4yOCwxMy43YzUuNS04LjMyLDEzLjE4LTEzLjcsMjIuMjctMTMuNywxMS4zOSwwLDE5LjIsNy41NSwxOS4yLDIxLjEydjUwLjY5aC0xNi4xM3YtNDYuMjFjMC03Ljk0LTMuNDYtMTEuNzgtOS43My0xMS43OC01LjUsMC0xMS4zOSw0Ljg2LTE0LjcyLDExLjl2NDYuMDhoLTE1Ljg3di00Ni4yMWMwLTguMDYtMy4wNy0xMS43OC04LjctMTEuNzhzLTExLjY1LDQuNzQtMTUuMjMsMTEuOXY0Ni4wOGgtMTUuODd2LTcwLjI3aDE1LjM2djEyLjI5WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNDY2LjQ2LDQ4Ny42OGM1LjUtOC40NSwxMy4wNi0xMy44MiwyMi4xNS0xMy44MnMxNS40OSw1LjUsMTcuMjgsMTMuN2M1LjUtOC4zMiwxMy4xOC0xMy43LDIyLjI3LTEzLjcsMTEuMzksMCwxOS4yLDcuNTUsMTkuMiwyMS4xMnY1MC42OWgtMTYuMTN2LTQ2LjIxYzAtNy45NC0zLjQ2LTExLjc4LTkuNzMtMTEuNzgtNS41LDAtMTEuMzksNC44Ni0xNC43MiwxMS45djQ2LjA4aC0xNS44N3YtNDYuMjFjMC04LjA2LTMuMDctMTEuNzgtOC43LTExLjc4cy0xMS42NSw0Ljc0LTE1LjIzLDExLjl2NDYuMDhoLTE1Ljg3di03MC4yN2gxNS4zNnYxMi4yOVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTU5OC4xOCw1NDguMjJjLTUuNSwxNi4xMy0xMy45NSwyMi4xNS0yOC4yOSwyMi4xNS0yLjY5LDAtNS4zOC0uMTMtOC43MS0uNjRsLS42NC0xMi4yOWMzLjQ2LjY0LDYuMTQuOSw4Ljk2LjksNi41MywwLDEwLjg4LTMuNDYsMTMuMzEtMTAuODhsMS4wMi0zLjA3LTIzLjgxLTY5aDE3LjAzbDguMzIsMjkuNDRjMi4zLDguMDYsMy44NCwxNC44NSw1Ljg5LDIzLjA0aDEuMjhjMi4xOC03Ljk0LDMuOTctMTUuMSw2LjI3LTIzLjNsOC4wNi0yOS4xOWgxNmwtMjQuNzEsNzIuODNaIi8+CiAgPC9nPgo8L3N2Zz4=',
  'C9': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0idGV4dCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA4MDAgODAwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiBub25lOwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgc3Ryb2tlLXdpZHRoOiAwcHg7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogIzAwMDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgogIDxnPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzgzLjkxLDI3MC44NWMtMi40My0xMy44Mi05LjYtMjAuOTktMjAuODctMjAuOTktMTQuNzIsMC0yNC45NiwxMi44LTI0Ljk2LDM4LjE1czEwLjUsMzguMTUsMjQuOTYsMzguMTVjMTEuOSwwLDE5LjA3LTYuNzgsMjEuODktMjEuMjVsMTYuMjYsNC45OWMtNS4yNSwyMC40OC0xOC4wNSwyOS41Ny0zOC4yNywyOS41Ny0yNS43MywwLTQzLjE0LTE4LjU2LTQzLjE0LTUxLjMzczE3LjU0LTUxLjU5LDQzLjE0LTUxLjU5YzIwLjM1LDAsMzMuNjcsMTEuMzksMzcuNzYsMzAuMjFsLTE2Ljc3LDQuMVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQyOC45NiwzMTcuODJjMS43OSw2LjUzLDQuODYsOS4zNCwxMC4yNCw5LjM0LDEwLjg4LDAsMTcuMTUtOS4yMiwxNy43OS0zNC44Mi00LjIyLDcuOTQtMTEuMDEsMTEuNjUtMTkuOTcsMTEuNjUtMTQuODUsMC0yNS45OS0xMi4xNi0yNS45OS0zMS40OSwwLTIxLjEyLDExLjUyLTM0LjE4LDI5LjQ0LTM0LjE4LDE5LjMzLDAsMzEuNzUsMTMuOTUsMzEuNzUsNDYuODUsMCwzOS4wNC0xMi4yOSw1NC4yNy0zMy4yOCw1NC4yNy0xMy4zMSwwLTIxLjc2LTUuMjUtMjUuNzMtMTUuNzRsMTUuNzUtNS44OVpNNDQxLjEyLDI1MC42MmMtOS40NywwLTEzLjgyLDguMTktMTMuODIsMjEuNSwwLDEyLjQyLDUuMjUsMTkuNTgsMTMuNDQsMTkuNTgsNy4wNCwwLDEyLjAzLTQuMzUsMTUuNDktMTIuMjktLjEzLTE5LjA3LTQuNjEtMjguOC0xNS4xLTI4LjhaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0yMzQuNjYsNTQ1LjY2aC0xNS40OXYtOS43M2MtNC42MSw3LjgxLTExLjM5LDExLjUyLTE5LjcxLDExLjUyLTE1LjEsMC0yNi44OC0xMy4xOC0yNi44OC0zNy4yNXMxMi4wMy0zNi4yMywyNi44OC0zNi4yM2M3LjgxLDAsMTQuOTgsMy45NywxOS4yLDExLjE0di00MC41OGgxNnYxMDEuMTJaTTIxOC42Niw0OTguNTZjLTMuMzMtOC4xOS04LjgzLTEyLjAzLTE0LjU5LTEyLjAzLTguMDYsMC0xNC45OCw3LjMtMTQuOTgsMjMuOTRzNi45MSwyNC40NSwxNS4zNiwyNC40NWM1Ljg5LDAsMTEuMDEtNC4zNSwxNC4yMS0xMS43OHYtMjQuNThaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0zMTMuNzYsNTQ1LjY2aC0xNS42MnYtMTIuMTZjLTQuOTksOC40NS0xMy40NCwxMy45NS0yMi43OSwxMy45NS0xMS4zOSwwLTIwLjM1LTYuOTEtMjAuMzUtMjAuNzR2LTUxLjMzaDE2LjUxdjQ2LjcyYzAsNy45NCwzLjU4LDExLjUyLDkuODYsMTEuNTJzMTIuNjctNS4xMiwxNi4yNi0xMi4wM3YtNDYuMjFoMTYuMTN2NzAuMjdaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0zNDkuODYsNDg3LjY4YzUuNS04LjQ1LDEzLjA2LTEzLjgyLDIyLjE1LTEzLjgyczE1LjQ5LDUuNSwxNy4yOCwxMy43YzUuNS04LjMyLDEzLjE4LTEzLjcsMjIuMjctMTMuNywxMS4zOSwwLDE5LjIsNy41NSwxOS4yLDIxLjEydjUwLjY5aC0xNi4xM3YtNDYuMjFjMC03Ljk0LTMuNDYtMTEuNzgtOS43My0xMS43OC01LjUsMC0xMS4zOSw0Ljg2LTE0LjcyLDExLjl2NDYuMDhoLTE1Ljg3di00Ni4yMWMwLTguMDYtMy4wNy0xMS43OC04LjctMTEuNzhzLTExLjY1LDQuNzQtMTUuMjMsMTEuOXY0Ni4wOGgtMTUuODd2LTcwLjI3aDE1LjM2djEyLjI5WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNDY2LjQ2LDQ4Ny42OGM1LjUtOC40NSwxMy4wNi0xMy44MiwyMi4xNS0xMy44MnMxNS40OSw1LjUsMTcuMjgsMTMuN2M1LjUtOC4zMiwxMy4xOC0xMy43LDIyLjI3LTEzLjcsMTEuMzksMCwxOS4yLDcuNTUsMTkuMiwyMS4xMnY1MC42OWgtMTYuMTN2LTQ2LjIxYzAtNy45NC0zLjQ2LTExLjc4LTkuNzMtMTEuNzgtNS41LDAtMTEuMzksNC44Ni0xNC43MiwxMS45djQ2LjA4aC0xNS44N3YtNDYuMjFjMC04LjA2LTMuMDctMTEuNzgtOC43LTExLjc4cy0xMS42NSw0Ljc0LTE1LjIzLDExLjl2NDYuMDhoLTE1Ljg3di03MC4yN2gxNS4zNnYxMi4yOVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTU5OC4xOCw1NDguMjJjLTUuNSwxNi4xMy0xMy45NSwyMi4xNS0yOC4yOSwyMi4xNS0yLjY5LDAtNS4zOC0uMTMtOC43MS0uNjRsLS42NC0xMi4yOWMzLjQ2LjY0LDYuMTQuOSw4Ljk2LjksNi41MywwLDEwLjg4LTMuNDYsMTMuMzEtMTAuODhsMS4wMi0zLjA3LTIzLjgxLTY5aDE3LjAzbDguMzIsMjkuNDRjMi4zLDguMDYsMy44NCwxNC44NSw1Ljg5LDIzLjA0aDEuMjhjMi4xOC03Ljk0LDMuOTctMTUuMSw2LjI3LTIzLjNsOC4wNi0yOS4xOWgxNmwtMjQuNzEsNzIuODNaIi8+CiAgPC9nPgo8L3N2Zz4=',
  'D10': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBzdHJva2U6ICMwMDA7CiAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOwogICAgICAgIHN0cm9rZS13aWR0aDogMTBweDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGc+CiAgICA8bGluZSBjbGFzcz0iY2xzLTIiIHgxPSI4MCIgeTE9IjQ2NCIgeDI9IjIwOCIgeTI9IjMzNiIvPgogICAgPGxpbmUgY2xhc3M9ImNscy0yIiB4MT0iMTQ0IiB5MT0iNDY0IiB4Mj0iMjcyIiB5Mj0iMzM2Ii8+CiAgICA8bGluZSBjbGFzcz0iY2xzLTIiIHgxPSIyMjQiIHkxPSI0NjQiIHgyPSIzNTIiIHkyPSIzMzYiLz4KICAgIDxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjMzNiIgeTE9IjQ2NCIgeDI9IjQ2NCIgeTI9IjMzNiIvPgogICAgPGxpbmUgY2xhc3M9ImNscy0yIiB4MT0iNDQ4IiB5MT0iNDY0IiB4Mj0iNTc2IiB5Mj0iMzM2Ii8+CiAgICA8bGluZSBjbGFzcz0iY2xzLTIiIHgxPSI1MjgiIHkxPSI0NjQiIHgyPSI2NTYiIHkyPSIzMzYiLz4KICAgIDxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjU5MiIgeTE9IjQ2NCIgeDI9IjcyMCIgeTI9IjMzNiIvPgogIDwvZz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMSIgY3g9IjQwMCIgY3k9IjQwMCIgcj0iNDAwIi8+Cjwvc3ZnPg==',
  'D11': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZTogIzAwMDsKICAgICAgICBzdHJva2UtbWl0ZXJsaW1pdDogMTA7CiAgICAgICAgc3Ryb2tlLXdpZHRoOiA0MHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBzdHJva2Utd2lkdGg6IDBweDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGc+CiAgICA8bGluZSBjbGFzcz0iY2xzLTEiIHgxPSIzNDQiIHkxPSIzMzYiIHgyPSI1ODQiIHkyPSIzMzYiLz4KICAgIDxsaW5lIGNsYXNzPSJjbHMtMSIgeDE9IjQ4OCIgeTE9IjI0OCIgeDI9IjYxNiIgeTI9IjI0OCIvPgogICAgPGxpbmUgY2xhc3M9ImNscy0xIiB4MT0iNTg0IiB5MT0iMTg0IiB4Mj0iNjQ4IiB5Mj0iMTg0Ii8+CiAgICA8bGluZSBjbGFzcz0iY2xzLTEiIHgxPSI0NTYiIHkxPSI0NjQiIHgyPSIyMTYiIHkyPSI0NjQiLz4KICAgIDxsaW5lIGNsYXNzPSJjbHMtMSIgeDE9IjMxMiIgeTE9IjU1MiIgeDI9IjE4NCIgeTI9IjU1MiIvPgogICAgPGxpbmUgY2xhc3M9ImNscy0xIiB4MT0iMjE2IiB5MT0iNjE2IiB4Mj0iMTUyIiB5Mj0iNjE2Ii8+CiAgPC9nPgogIDxjaXJjbGUgY2xhc3M9ImNscy0yIiBjeD0iNDAwIiBjeT0iNDAwIiByPSI0MDAiLz4KPC9zdmc+',
  'D12': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0idGV4dCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA4MDAgODAwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiBub25lOwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgc3Ryb2tlLXdpZHRoOiAwcHg7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogIzAwMDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgogIDxnPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzE4LjQ0LDIzOC4zM2MyOS41NywwLDQ3LjIzLDE1LjYyLDQ3LjIzLDQ5LjAzcy0xOS43MSw1MC4zMS00OS41NCw1MC4zMWgtMzAuOTh2LTk5LjMzaDMzLjI4Wk0zMDIuMzEsMzI0LjM1aDEzLjQ0YzE5LjMzLDAsMzEuNjItMTEuMDEsMzEuNjItMzYuODdzLTExLjUyLTM1Ljg0LTMwLjcyLTM1Ljg0aC0xNC4zNHY3Mi43MVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQxOC4wMiwzMjUuMjVoMTguM3YxMi40MmgtNTIuNzR2LTEyLjQyaDE5LjJ2LTY5LjY0Yy00Ljg2LDMuMzMtMTEuMDEsNi40LTE4LjA1LDguN2wtMi41Ni0xMy40NGM4LjQ1LTIuNDMsMTYtNi41MywyMi43OS0xMS41MmgxMy4wNnY4NS44OVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQ1Mi4xOSwyNjUuMzRjMi4xOC0xNy41NCwxNC4wOC0yNy4wMSwzMC4wOC0yNy4wMSwxNy41NCwwLDI5LjE5LDkuNDcsMjkuMTksMjYuMzcsMCwxMC44OC00Ljc0LDE5LjA3LTE5LjcxLDMzLjAzLTEzLjQ0LDEyLjAzLTE5Ljg0LDE5LjItMjMuODEsMjcuMTRoNDMuOTF2MTIuOGgtNjAuNTV2LTExLjM5YzUuNzYtMTIuMDMsMTMuOTUtMjIuNzgsMjcuOTEtMzYuMjMsMTIuOC0xMi4yOSwxNS42Mi0xNy40MSwxNS42Mi0yNS40NywwLTguNTgtNC45OS0xMy41Ny0xMi44LTEzLjU3cy0xMy4wNiw2LjAyLTEzLjgzLDE3LjY2bC0xNi0zLjMzWiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMjM0LjY2LDU0NS42NmgtMTUuNDl2LTkuNzNjLTQuNjEsNy44MS0xMS4zOSwxMS41Mi0xOS43MSwxMS41Mi0xNS4xLDAtMjYuODgtMTMuMTgtMjYuODgtMzcuMjVzMTIuMDMtMzYuMjMsMjYuODgtMzYuMjNjNy44MSwwLDE0Ljk4LDMuOTcsMTkuMiwxMS4xNHYtNDAuNThoMTZ2MTAxLjEyWk0yMTguNjYsNDk4LjU2Yy0zLjMzLTguMTktOC44My0xMi4wMy0xNC41OS0xMi4wMy04LjA2LDAtMTQuOTgsNy4zLTE0Ljk4LDIzLjk0czYuOTEsMjQuNDUsMTUuMzYsMjQuNDVjNS44OSwwLDExLjAxLTQuMzUsMTQuMjEtMTEuNzh2LTI0LjU4WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzEzLjc2LDU0NS42NmgtMTUuNjJ2LTEyLjE2Yy00Ljk5LDguNDUtMTMuNDQsMTMuOTUtMjIuNzksMTMuOTUtMTEuMzksMC0yMC4zNS02LjkxLTIwLjM1LTIwLjc0di01MS4zM2gxNi41MXY0Ni43MmMwLDcuOTQsMy41OCwxMS41Miw5Ljg2LDExLjUyczEyLjY3LTUuMTIsMTYuMjYtMTIuMDN2LTQ2LjIxaDE2LjEzdjcwLjI3WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzQ5Ljg2LDQ4Ny42OGM1LjUtOC40NSwxMy4wNi0xMy44MiwyMi4xNS0xMy44MnMxNS40OSw1LjUsMTcuMjgsMTMuN2M1LjUtOC4zMiwxMy4xOC0xMy43LDIyLjI3LTEzLjcsMTEuMzksMCwxOS4yLDcuNTUsMTkuMiwyMS4xMnY1MC42OWgtMTYuMTN2LTQ2LjIxYzAtNy45NC0zLjQ2LTExLjc4LTkuNzMtMTEuNzgtNS41LDAtMTEuMzksNC44Ni0xNC43MiwxMS45djQ2LjA4aC0xNS44N3YtNDYuMjFjMC04LjA2LTMuMDctMTEuNzgtOC43LTExLjc4cy0xMS42NSw0Ljc0LTE1LjIzLDExLjl2NDYuMDhoLTE1Ljg3di03MC4yN2gxNS4zNnYxMi4yOVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQ2Ni40Niw0ODcuNjhjNS41LTguNDUsMTMuMDYtMTMuODIsMjIuMTUtMTMuODJzMTUuNDksNS41LDE3LjI4LDEzLjdjNS41LTguMzIsMTMuMTgtMTMuNywyMi4yNy0xMy43LDExLjM5LDAsMTkuMiw3LjU1LDE5LjIsMjEuMTJ2NTAuNjloLTE2LjEzdi00Ni4yMWMwLTcuOTQtMy40Ni0xMS43OC05LjczLTExLjc4LTUuNSwwLTExLjM5LDQuODYtMTQuNzIsMTEuOXY0Ni4wOGgtMTUuODd2LTQ2LjIxYzAtOC4wNi0zLjA3LTExLjc4LTguNy0xMS43OHMtMTEuNjUsNC43NC0xNS4yMywxMS45djQ2LjA4aC0xNS44N3YtNzAuMjdoMTUuMzZ2MTIuMjlaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik01OTguMTgsNTQ4LjIyYy01LjUsMTYuMTMtMTMuOTUsMjIuMTUtMjguMjksMjIuMTUtMi42OSwwLTUuMzgtLjEzLTguNzEtLjY0bC0uNjQtMTIuMjljMy40Ni42NCw2LjE0LjksOC45Ni45LDYuNTMsMCwxMC44OC0zLjQ2LDEzLjMxLTEwLjg4bDEuMDItMy4wNy0yMy44MS02OWgxNy4wM2w4LjMyLDI5LjQ0YzIuMyw4LjA2LDMuODQsMTQuODUsNS44OSwyMy4wNGgxLjI4YzIuMTgtNy45NCwzLjk3LTE1LjEsNi4yNy0yMy4zbDguMDYtMjkuMTloMTZsLTI0LjcxLDcyLjgzWiIvPgogIDwvZz4KPC9zdmc+',
  'E13': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBzdHJva2U6ICMwMDA7CiAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOwogICAgICAgIHN0cm9rZS13aWR0aDogMTBweDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNTU2LDMxNkgyNDRjLTQ2LjM5LDAtODQsMzcuNjEtODQsODRzMzcuNjEsODQsODQsODRoMzEyYzQ2LjM5LDAsODQtMzcuNjEsODQtODRzLTM3LjYxLTg0LTg0LTg0WiIvPgogIDxjaXJjbGUgY2xhc3M9ImNscy0xIiBjeD0iNDAwIiBjeT0iNDAwIiByPSI0MDAiLz4KPC9zdmc+',
  'E14': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6IG5vbmU7CiAgICAgIH0KCiAgICAgIC5jbHMtMSwgLmNscy0yLCAuY2xzLTMsIC5jbHMtNCwgLmNscy01IHsKICAgICAgICBzdHJva2Utd2lkdGg6IDBweDsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBmaWxsOiAjYWFhOwogICAgICB9CgogICAgICAuY2xzLTIsIC5jbHMtMywgLmNscy00LCAuY2xzLTUgewogICAgICAgIGZpbGwtcnVsZTogZXZlbm9kZDsKICAgICAgfQoKICAgICAgLmNscy0zIHsKICAgICAgICBmaWxsOiAjNTU1OwogICAgICB9CgogICAgICAuY2xzLTQgewogICAgICAgIGZpbGw6ICNmZmY7CiAgICAgIH0KCiAgICAgIC5jbHMtNSB7CiAgICAgICAgZmlsbDogIzAwMDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGc+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTUiIGQ9Ik01NTYsMzE2SDI0NGMtNDYuMzksMC04NCwzNy42MS04NCw4NHMzNy42MSw4NCw4NCw4NGgzMTJjNDYuMzksMCw4NC0zNy42MSw4NC04NHMtMzcuNjEtODQtODQtODRaTTU1Niw0NjBIMjQ0Yy0zMy4xNCwwLTYwLTI2Ljg2LTYwLTYwczI2Ljg2LTYwLDYwLTYwaDMxMmMzMy4xNCwwLDYwLDI2Ljg2LDYwLDYwcy0yNi44Niw2MC02MCw2MFoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTU1NiwzNDBIMjQ0Yy0zMy4xNCwwLTYwLDI2Ljg2LTYwLDYwczI2Ljg2LDYwLDYwLDYwaDMxMmMzMy4xNCwwLDYwLTI2Ljg2LDYwLTYwcy0yNi44Ni02MC02MC02MFpNNTU2LDQzNkgyNDRjLTE5Ljg4LDAtMzYtMTYuMTItMzYtMzZzMTYuMTItMzYsMzYtMzZoMzEyYzE5Ljg4LDAsMzYsMTYuMTIsMzYsMzZzLTE2LjEyLDM2LTM2LDM2WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNTU2LDM2NEgyNDRjLTE5Ljg4LDAtMzYsMTYuMTItMzYsMzZzMTYuMTIsMzYsMzYsMzZoMzEyYzE5Ljg4LDAsMzYtMTYuMTIsMzYtMzZzLTE2LjEyLTM2LTM2LTM2Wk01NTYsNDEySDI0NGMtNi42MywwLTEyLTUuMzctMTItMTJzNS4zNy0xMiwxMi0xMmgzMTJjNi42MywwLDEyLDUuMzcsMTIsMTJzLTUuMzcsMTItMTIsMTJaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTQiIGQ9Ik01NTYsMzg4SDI0NGMtNi42MywwLTEyLDUuMzctMTIsMTJzNS4zNywxMiwxMiwxMmgzMTJjNi42MywwLDEyLTUuMzcsMTItMTJzLTUuMzctMTItMTItMTJaIi8+CiAgPC9nPgogIDxjaXJjbGUgY2xhc3M9ImNscy0xIiBjeD0iNDAwIiBjeT0iNDAwIiByPSI0MDAiLz4KPC9zdmc+',
  'E15': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6IG5vbmU7CiAgICAgIH0KCiAgICAgIC5jbHMtMSwgLmNscy0yLCAuY2xzLTMgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTIgewogICAgICAgIGZpbGw6IHNpbHZlcjsKICAgICAgfQoKICAgICAgLmNscy0yLCAuY2xzLTMgewogICAgICAgIGZpbGwtcnVsZTogZXZlbm9kZDsKICAgICAgfQoKICAgICAgLmNscy0zIHsKICAgICAgICBmaWxsOiAjYTBhMGEwOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8Zz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTU1NiwzMTZIMjQ0Yy00Ni4zOSwwLTg0LDM3LjYxLTg0LDg0czM3LjYxLDg0LDg0LDg0aDMxMmM0Ni4zOSwwLDg0LTM3LjYxLDg0LTg0cy0zNy42MS04NC04NC04NFpNNTU2LDQ2MEgyNDRjLTMzLjE0LDAtNjAtMjYuODYtNjAtNjBzMjYuODYtNjAsNjAtNjBoMzEyYzMzLjE0LDAsNjAsMjYuODYsNjAsNjBzLTI2Ljg2LDYwLTYwLDYwWiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0zIiBkPSJNNTU2LDM0MEgyNDRjLTMzLjE0LDAtNjAsMjYuODYtNjAsNjBzMjYuODYsNjAsNjAsNjBoMzEyYzMzLjE0LDAsNjAtMjYuODYsNjAtNjBzLTI2Ljg2LTYwLTYwLTYwWk01NTYsNDM2SDI0NGMtMTkuODgsMC0zNi0xNi4xMi0zNi0zNnMxNi4xMi0zNiwzNi0zNmgzMTJjMTkuODgsMCwzNiwxNi4xMiwzNiwzNnMtMTYuMTIsMzYtMzYsMzZaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik01NTYsMzY0SDI0NGMtMTkuODgsMC0zNiwxNi4xMi0zNiwzNnMxNi4xMiwzNiwzNiwzNmgzMTJjMTkuODgsMCwzNi0xNi4xMiwzNi0zNnMtMTYuMTItMzYtMzYtMzZaTTU1Niw0MTJIMjQ0Yy02LjYzLDAtMTItNS4zNy0xMi0xMnM1LjM3LTEyLDEyLTEyaDMxMmM2LjYzLDAsMTIsNS4zNywxMiwxMnMtNS4zNywxMi0xMiwxMloiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTU1NiwzODhIMjQ0Yy02LjYzLDAtMTIsNS4zNy0xMiwxMnM1LjM3LDEyLDEyLDEyaDMxMmM2LjYzLDAsMTItNS4zNywxMi0xMnMtNS4zNy0xMi0xMi0xMloiLz4KICA8L2c+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgo8L3N2Zz4=',
  'F16': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6IG5vbmU7CiAgICAgIH0KCiAgICAgIC5jbHMtMSwgLmNscy0yIHsKICAgICAgICBzdHJva2Utd2lkdGg6IDBweDsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBmaWxsOiAjMDAwOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMiIgY3g9IjE5MiIgY3k9IjQwMCIgcj0iMzIiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMiIgY3g9IjI4OCIgY3k9IjQwMCIgcj0iMzIiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMiIgY3g9IjQwMCIgY3k9IjQwMCIgcj0iMzIiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMiIgY3g9IjUxMiIgY3k9IjQwMCIgcj0iMzIiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMiIgY3g9IjYwOCIgY3k9IjQwMCIgcj0iMzIiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMSIgY3g9IjQwMCIgY3k9IjQwMCIgcj0iNDAwIi8+Cjwvc3ZnPg==',
  'F17': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiwgLmNscy0zLCAuY2xzLTQsIC5jbHMtNSB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBzdHJva2Utd2lkdGg6IDI4LjhweDsKICAgICAgfQoKICAgICAgLmNscy0yLCAuY2xzLTMsIC5jbHMtNCwgLmNscy01IHsKICAgICAgICBzdHJva2U6ICMwMDA7CiAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOwogICAgICB9CgogICAgICAuY2xzLTMgewogICAgICAgIHN0cm9rZS13aWR0aDogMTBweDsKICAgICAgfQoKICAgICAgLmNscy00IHsKICAgICAgICBzdHJva2Utd2lkdGg6IDE2cHg7CiAgICAgIH0KCiAgICAgIC5jbHMtNSB7CiAgICAgICAgc3Ryb2tlLXdpZHRoOiAzNnB4OwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMiIgY3g9IjIxNiIgY3k9IjQwMCIgcj0iNzIiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtNCIgY3g9IjQwMCIgY3k9IjQwMCIgcj0iNzIiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtNSIgY3g9IjQ4OCIgY3k9IjQwMCIgcj0iNzIiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMyIgY3g9IjU5MiIgY3k9IjQwMCIgcj0iNzIiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMSIgY3g9IjQwMCIgY3k9IjQwMCIgcj0iNDAwIi8+Cjwvc3ZnPg==',
  'F18': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iZGVzaWduIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDgwMCA4MDAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIHN0cm9rZS13aWR0aDogMHB4OwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgZmlsbDogbm9uZTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBzdHJva2U6ICMwMDA7CiAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOwogICAgICAgIHN0cm9rZS13aWR0aDogMTBweDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMjU2LDMwNGMtNTMuMDIsMC05Niw0Mi45OC05Niw5NnM0Mi45OCw5Niw5Niw5Niw5Ni00Mi45OCw5Ni05Ni00Mi45OC05Ni05Ni05NlpNNTQ0LDMwNGMtMTcuNDksMC0zMy44OCw0LjY4LTQ4LDEyLjg1LTE0LjEyLTguMTctMzAuNTEtMTIuODUtNDgtMTIuODUtNTMuMDIsMC05Niw0Mi45OC05Niw5NnM0Mi45OCw5Niw5Niw5NmMxNy40OSwwLDMzLjg4LTQuNjgsNDgtMTIuODUsMTQuMTIsOC4xNywzMC41MSwxMi44NSw0OCwxMi44NSw1My4wMiwwLDk2LTQyLjk4LDk2LTk2cy00Mi45OC05Ni05Ni05NloiLz4KICA8Y2lyY2xlIGNsYXNzPSJjbHMtMSIgY3g9IjQwMCIgY3k9IjQwMCIgcj0iNDAwIi8+Cjwvc3ZnPg==',
  'G19': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0idGV4dCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA4MDAgODAwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiBub25lOwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgc3Ryb2tlLXdpZHRoOiAwcHg7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogIzAwMDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgogIDxnPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzQ0LjI5LDI2OS42OWMtMi40My0xMi41NC05LjIyLTE5LjcxLTIwLjYxLTE5LjcxLTE1LjEsMC0yNS4yMiwxMi44LTI1LjIyLDM4LjE1czkuODYsMzguMTUsMjQuOTYsMzguMTVjMTMuOTUsMCwyMC42MS0xMS4xNCwyMi4xNS0yNy4wMWgtMjMuMTd2LTEzLjMxaDM5LjN2NTIuMzVoLTExLjUybC0xLjkyLTE0LjQ2Yy01LjEyLDEwLjI0LTE0LjcyLDE1Ljc1LTI2LjYzLDE1Ljc1LTI0LjcxLDAtNDEuNDctMTguNDMtNDEuNDctNTEuMzNzMTcuNzktNTEuNTksNDMuMjctNTEuNTljMjAuNjEsMCwzMy40MSwxMS41MiwzNy42MywyOS4wNmwtMTYuNzcsMy45N1oiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQxNy41MSwzMjUuMjVoMTguM3YxMi40MmgtNTIuNzR2LTEyLjQyaDE5LjJ2LTY5LjY0Yy00Ljg2LDMuMzMtMTEuMDEsNi40LTE4LjA1LDguN2wtMi41Ni0xMy40NGM4LjQ1LTIuNDMsMTYtNi41MywyMi43OS0xMS41MmgxMy4wNnY4NS44OVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQ2OC41OCwzMTcuODJjMS43OSw2LjUzLDQuODYsOS4zNCwxMC4yNCw5LjM0LDEwLjg4LDAsMTcuMTUtOS4yMiwxNy43OS0zNC44Mi00LjIyLDcuOTQtMTEuMDEsMTEuNjUtMTkuOTcsMTEuNjUtMTQuODUsMC0yNS45OS0xMi4xNi0yNS45OS0zMS40OSwwLTIxLjEyLDExLjUyLTM0LjE4LDI5LjQ0LTM0LjE4LDE5LjMzLDAsMzEuNzUsMTMuOTUsMzEuNzUsNDYuODUsMCwzOS4wNC0xMi4yOSw1NC4yNy0zMy4yOCw1NC4yNy0xMy4zMSwwLTIxLjc2LTUuMjUtMjUuNzMtMTUuNzRsMTUuNzQtNS44OVpNNDgwLjc0LDI1MC42MmMtOS40NywwLTEzLjgyLDguMTktMTMuODIsMjEuNSwwLDEyLjQyLDUuMjUsMTkuNTgsMTMuNDQsMTkuNTgsNy4wNCwwLDEyLjAzLTQuMzUsMTUuNDktMTIuMjktLjEzLTE5LjA3LTQuNjEtMjguOC0xNS4xLTI4LjhaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0yMzQuNjYsNTQ1LjY2aC0xNS40OXYtOS43M2MtNC42MSw3LjgxLTExLjM5LDExLjUyLTE5LjcxLDExLjUyLTE1LjEsMC0yNi44OC0xMy4xOC0yNi44OC0zNy4yNXMxMi4wMy0zNi4yMywyNi44OC0zNi4yM2M3LjgxLDAsMTQuOTgsMy45NywxOS4yLDExLjE0di00MC41OGgxNnYxMDEuMTJaTTIxOC42Niw0OTguNTZjLTMuMzMtOC4xOS04LjgzLTEyLjAzLTE0LjU5LTEyLjAzLTguMDYsMC0xNC45OCw3LjMtMTQuOTgsMjMuOTRzNi45MSwyNC40NSwxNS4zNiwyNC40NWM1Ljg5LDAsMTEuMDEtNC4zNSwxNC4yMS0xMS43OHYtMjQuNThaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0zMTMuNzYsNTQ1LjY2aC0xNS42MnYtMTIuMTZjLTQuOTksOC40NS0xMy40NCwxMy45NS0yMi43OSwxMy45NS0xMS4zOSwwLTIwLjM1LTYuOTEtMjAuMzUtMjAuNzR2LTUxLjMzaDE2LjUxdjQ2LjcyYzAsNy45NCwzLjU4LDExLjUyLDkuODYsMTEuNTJzMTIuNjctNS4xMiwxNi4yNi0xMi4wM3YtNDYuMjFoMTYuMTN2NzAuMjdaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0zNDkuODYsNDg3LjY4YzUuNS04LjQ1LDEzLjA2LTEzLjgyLDIyLjE1LTEzLjgyczE1LjQ5LDUuNSwxNy4yOCwxMy43YzUuNS04LjMyLDEzLjE4LTEzLjcsMjIuMjctMTMuNywxMS4zOSwwLDE5LjIsNy41NSwxOS4yLDIxLjEydjUwLjY5aC0xNi4xM3YtNDYuMjFjMC03Ljk0LTMuNDYtMTEuNzgtOS43My0xMS43OC01LjUsMC0xMS4zOSw0Ljg2LTE0LjcyLDExLjl2NDYuMDhoLTE1Ljg3di00Ni4yMWMwLTguMDYtMy4wNy0xMS43OC04LjctMTEuNzhzLTExLjY1LDQuNzQtMTUuMjMsMTEuOXY0Ni4wOGgtMTUuODd2LTcwLjI3aDE1LjM2djEyLjI5WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNDY2LjQ3LDQ4Ny42OGM1LjUtOC40NSwxMy4wNi0xMy44MiwyMi4xNS0xMy44MnMxNS40OSw1LjUsMTcuMjgsMTMuN2M1LjUtOC4zMiwxMy4xOC0xMy43LDIyLjI3LTEzLjcsMTEuMzksMCwxOS4yLDcuNTUsMTkuMiwyMS4xMnY1MC42OWgtMTYuMTN2LTQ2LjIxYzAtNy45NC0zLjQ2LTExLjc4LTkuNzMtMTEuNzgtNS41LDAtMTEuMzksNC44Ni0xNC43MiwxMS45djQ2LjA4aC0xNS44N3YtNDYuMjFjMC04LjA2LTMuMDctMTEuNzgtOC43LTExLjc4cy0xMS42NSw0Ljc0LTE1LjIzLDExLjl2NDYuMDhoLTE1Ljg3di03MC4yN2gxNS4zNnYxMi4yOVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTU5OC4xOCw1NDguMjJjLTUuNSwxNi4xMy0xMy45NSwyMi4xNS0yOC4yOSwyMi4xNS0yLjY5LDAtNS4zOC0uMTMtOC43LS42NGwtLjY0LTEyLjI5YzMuNDYuNjQsNi4xNC45LDguOTYuOSw2LjUzLDAsMTAuODgtMy40NiwxMy4zMS0xMC44OGwxLjAyLTMuMDctMjMuODEtNjloMTcuMDJsOC4zMiwyOS40NGMyLjMsOC4wNiwzLjg0LDE0Ljg1LDUuODksMjMuMDRoMS4yOGMyLjE4LTcuOTQsMy45Ny0xNS4xLDYuMjctMjMuM2w4LjA2LTI5LjE5aDE2bC0yNC43MSw3Mi44M1oiLz4KICA8L2c+Cjwvc3ZnPg==',
  'G20': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0idGV4dCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA4MDAgODAwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiBub25lOwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgc3Ryb2tlLXdpZHRoOiAwcHg7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogIzAwMDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgogIDxnPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzQ0LjI5LDI2OS42OWMtMi40My0xMi41NC05LjIyLTE5LjcxLTIwLjYxLTE5LjcxLTE1LjEsMC0yNS4yMiwxMi44LTI1LjIyLDM4LjE1czkuODYsMzguMTUsMjQuOTYsMzguMTVjMTMuOTUsMCwyMC42MS0xMS4xNCwyMi4xNS0yNy4wMWgtMjMuMTd2LTEzLjMxaDM5LjN2NTIuMzVoLTExLjUybC0xLjkyLTE0LjQ2Yy01LjEyLDEwLjI0LTE0LjcyLDE1Ljc1LTI2LjYzLDE1Ljc1LTI0LjcxLDAtNDEuNDctMTguNDMtNDEuNDctNTEuMzNzMTcuNzktNTEuNTksNDMuMjctNTEuNTljMjAuNjEsMCwzMy40MSwxMS41MiwzNy42MywyOS4wNmwtMTYuNzcsMy45N1oiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTM3OC4zNCwyNjUuMzRjMi4xOC0xNy41NCwxNC4wOC0yNy4wMSwzMC4wOC0yNy4wMSwxNy41NCwwLDI5LjE5LDkuNDcsMjkuMTksMjYuMzcsMCwxMC44OC00Ljc0LDE5LjA3LTE5LjcxLDMzLjAzLTEzLjQ0LDEyLjAzLTE5Ljg0LDE5LjItMjMuODEsMjcuMTRoNDMuOTF2MTIuOGgtNjAuNTV2LTExLjM5YzUuNzYtMTIuMDMsMTMuOTUtMjIuNzgsMjcuOTEtMzYuMjMsMTIuOC0xMi4yOSwxNS42Mi0xNy40MSwxNS42Mi0yNS40NywwLTguNTgtNC45OS0xMy41Ny0xMi44LTEzLjU3cy0xMy4wNiw2LjAyLTEzLjgzLDE3LjY2bC0xNi0zLjMzWiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNTEyLjM1LDI4OC41MWMwLDM2LjIzLTExLjAxLDUwLjk1LTMwLjk4LDUwLjk1cy0zMC41OS0xNC40Ni0zMC41OS01MC42OSwxMS4xNC01MC40MywzMC44NS01MC40MywzMC43MiwxNC4wOCwzMC43Miw1MC4xOFpNNDY3LjMsMjg4LjY0YzAsMjguOCwzLjk3LDM4LjE1LDE0LjA4LDM4LjE1czE0LjQ2LTkuNDcsMTQuNDYtMzguMTUtMy45Ny0zNy42My0xNC4yMS0zNy42My0xNC4zNCw4LjctMTQuMzQsMzcuNjNaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0yMzQuNjYsNTQ1LjY2aC0xNS40OXYtOS43M2MtNC42MSw3LjgxLTExLjM5LDExLjUyLTE5LjcxLDExLjUyLTE1LjEsMC0yNi44OC0xMy4xOC0yNi44OC0zNy4yNXMxMi4wMy0zNi4yMywyNi44OC0zNi4yM2M3LjgxLDAsMTQuOTgsMy45NywxOS4yLDExLjE0di00MC41OGgxNnYxMDEuMTJaTTIxOC42Niw0OTguNTZjLTMuMzMtOC4xOS04LjgzLTEyLjAzLTE0LjU5LTEyLjAzLTguMDYsMC0xNC45OCw3LjMtMTQuOTgsMjMuOTRzNi45MSwyNC40NSwxNS4zNiwyNC40NWM1Ljg5LDAsMTEuMDEtNC4zNSwxNC4yMS0xMS43OHYtMjQuNThaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0zMTMuNzYsNTQ1LjY2aC0xNS42MnYtMTIuMTZjLTQuOTksOC40NS0xMy40NCwxMy45NS0yMi43OSwxMy45NS0xMS4zOSwwLTIwLjM1LTYuOTEtMjAuMzUtMjAuNzR2LTUxLjMzaDE2LjUxdjQ2LjcyYzAsNy45NCwzLjU4LDExLjUyLDkuODYsMTEuNTJzMTIuNjctNS4xMiwxNi4yNi0xMi4wM3YtNDYuMjFoMTYuMTN2NzAuMjdaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0zNDkuODYsNDg3LjY4YzUuNS04LjQ1LDEzLjA2LTEzLjgyLDIyLjE1LTEzLjgyczE1LjQ5LDUuNSwxNy4yOCwxMy43YzUuNS04LjMyLDEzLjE4LTEzLjcsMjIuMjctMTMuNywxMS4zOSwwLDE5LjIsNy41NSwxOS4yLDIxLjEydjUwLjY5aC0xNi4xM3YtNDYuMjFjMC03Ljk0LTMuNDYtMTEuNzgtOS43My0xMS43OC01LjUsMC0xMS4zOSw0Ljg2LTE0LjcyLDExLjl2NDYuMDhoLTE1Ljg3di00Ni4yMWMwLTguMDYtMy4wNy0xMS43OC04LjctMTEuNzhzLTExLjY1LDQuNzQtMTUuMjMsMTEuOXY0Ni4wOGgtMTUuODd2LTcwLjI3aDE1LjM2djEyLjI5WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNDY2LjQ2LDQ4Ny42OGM1LjUtOC40NSwxMy4wNi0xMy44MiwyMi4xNS0xMy44MnMxNS40OSw1LjUsMTcuMjgsMTMuN2M1LjUtOC4zMiwxMy4xOC0xMy43LDIyLjI3LTEzLjcsMTEuMzksMCwxOS4yLDcuNTUsMTkuMiwyMS4xMnY1MC42OWgtMTYuMTN2LTQ2LjIxYzAtNy45NC0zLjQ2LTExLjc4LTkuNzMtMTEuNzgtNS41LDAtMTEuMzksNC44Ni0xNC43MiwxMS45djQ2LjA4aC0xNS44N3YtNDYuMjFjMC04LjA2LTMuMDctMTEuNzgtOC43LTExLjc4cy0xMS42NSw0Ljc0LTE1LjIzLDExLjl2NDYuMDhoLTE1Ljg3di03MC4yN2gxNS4zNnYxMi4yOVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTU5OC4xOCw1NDguMjJjLTUuNSwxNi4xMy0xMy45NSwyMi4xNS0yOC4yOSwyMi4xNS0yLjY5LDAtNS4zOC0uMTMtOC43MS0uNjRsLS42NC0xMi4yOWMzLjQ2LjY0LDYuMTQuOSw4Ljk2LjksNi41MywwLDEwLjg4LTMuNDYsMTMuMzEtMTAuODhsMS4wMi0zLjA3LTIzLjgxLTY5aDE3LjAzbDguMzIsMjkuNDRjMi4zLDguMDYsMy44NCwxNC44NSw1Ljg5LDIzLjA0aDEuMjhjMi4xOC03Ljk0LDMuOTctMTUuMSw2LjI3LTIzLjNsOC4wNi0yOS4xOWgxNmwtMjQuNzEsNzIuODNaIi8+CiAgPC9nPgo8L3N2Zz4=',
  'G21': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0idGV4dCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA4MDAgODAwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiBub25lOwogICAgICB9CgogICAgICAuY2xzLTEsIC5jbHMtMiB7CiAgICAgICAgc3Ryb2tlLXdpZHRoOiAwcHg7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogIzAwMDsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI0MDAiIGN5PSI0MDAiIHI9IjQwMCIvPgogIDxnPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzQ0LjI5LDI2OS42OWMtMi40My0xMi41NC05LjIyLTE5LjcxLTIwLjYxLTE5LjcxLTE1LjExLDAtMjUuMjIsMTIuOC0yNS4yMiwzOC4xNXM5Ljg2LDM4LjE1LDI0Ljk2LDM4LjE1YzEzLjk1LDAsMjAuNjEtMTEuMTQsMjIuMTQtMjcuMDFoLTIzLjE3di0xMy4zMWgzOS4zdjUyLjM1aC0xMS41MmwtMS45Mi0xNC40NmMtNS4xMiwxMC4yNC0xNC43MiwxNS43NS0yNi42MiwxNS43NS0yNC43MSwwLTQxLjQ3LTE4LjQzLTQxLjQ3LTUxLjMzczE3Ljc5LTUxLjU5LDQzLjI3LTUxLjU5YzIwLjYxLDAsMzMuNDEsMTEuNTIsMzcuNjMsMjkuMDZsLTE2Ljc3LDMuOTdaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0zNzguMzQsMjY1LjM0YzIuMTgtMTcuNTQsMTQuMDgtMjcuMDEsMzAuMDgtMjcuMDEsMTcuNTQsMCwyOS4xOSw5LjQ3LDI5LjE5LDI2LjM3LDAsMTAuODgtNC43NCwxOS4wNy0xOS43MSwzMy4wMy0xMy40NCwxMi4wMy0xOS44NCwxOS4yLTIzLjgxLDI3LjE0aDQzLjkxdjEyLjhoLTYwLjU1di0xMS4zOWM1Ljc2LTEyLjAzLDEzLjk1LTIyLjc4LDI3LjkxLTM2LjIzLDEyLjgtMTIuMjksMTUuNjItMTcuNDEsMTUuNjItMjUuNDcsMC04LjU4LTQuOTktMTMuNTctMTIuOC0xMy41N3MtMTMuMDYsNi4wMi0xMy44MywxNy42NmwtMTYtMy4zM1oiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTQ5MC44NSwzMjUuMjVoMTguM3YxMi40MmgtNTIuNzR2LTEyLjQyaDE5LjJ2LTY5LjY0Yy00Ljg2LDMuMzMtMTEuMDEsNi40LTE4LjA1LDguN2wtMi41Ni0xMy40NGM4LjQ1LTIuNDMsMTYtNi41MywyMi43OS0xMS41MmgxMy4wNnY4NS44OVoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTIzNC42Niw1NDUuNjZoLTE1LjQ5di05LjczYy00LjYxLDcuODEtMTEuMzksMTEuNTItMTkuNzEsMTEuNTItMTUuMSwwLTI2Ljg4LTEzLjE4LTI2Ljg4LTM3LjI1czEyLjAzLTM2LjIzLDI2Ljg4LTM2LjIzYzcuODEsMCwxNC45OCwzLjk3LDE5LjIsMTEuMTR2LTQwLjU4aDE2djEwMS4xMlpNMjE4LjY2LDQ5OC41NmMtMy4zMy04LjE5LTguODMtMTIuMDMtMTQuNTktMTIuMDMtOC4wNiwwLTE0Ljk4LDcuMy0xNC45OCwyMy45NHM2LjkxLDI0LjQ1LDE1LjM2LDI0LjQ1YzUuODksMCwxMS4wMS00LjM1LDE0LjIxLTExLjc4di0yNC41OFoiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTMxMy43Niw1NDUuNjZoLTE1LjYydi0xMi4xNmMtNC45OSw4LjQ1LTEzLjQ0LDEzLjk1LTIyLjc5LDEzLjk1LTExLjM5LDAtMjAuMzUtNi45MS0yMC4zNS0yMC43NHYtNTEuMzNoMTYuNTF2NDYuNzJjMCw3Ljk0LDMuNTgsMTEuNTIsOS44NiwxMS41MnMxMi42Ny01LjEyLDE2LjI2LTEyLjAzdi00Ni4yMWgxNi4xM3Y3MC4yN1oiLz4KICAgIDxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTM0OS44Niw0ODcuNjhjNS41LTguNDUsMTMuMDYtMTMuODIsMjIuMTUtMTMuODJzMTUuNDksNS41LDE3LjI4LDEzLjdjNS41LTguMzIsMTMuMTgtMTMuNywyMi4yNy0xMy43LDExLjM5LDAsMTkuMiw3LjU1LDE5LjIsMjEuMTJ2NTAuNjloLTE2LjEzdi00Ni4yMWMwLTcuOTQtMy40Ni0xMS43OC05LjczLTExLjc4LTUuNSwwLTExLjM5LDQuODYtMTQuNzIsMTEuOXY0Ni4wOGgtMTUuODd2LTQ2LjIxYzAtOC4wNi0zLjA3LTExLjc4LTguNy0xMS43OHMtMTEuNjUsNC43NC0xNS4yMywxMS45djQ2LjA4aC0xNS44N3YtNzAuMjdoMTUuMzZ2MTIuMjlaIi8+CiAgICA8cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik00NjYuNDYsNDg3LjY4YzUuNS04LjQ1LDEzLjA2LTEzLjgyLDIyLjE1LTEzLjgyczE1LjQ5LDUuNSwxNy4yOCwxMy43YzUuNS04LjMyLDEzLjE4LTEzLjcsMjIuMjctMTMuNywxMS4zOSwwLDE5LjIsNy41NSwxOS4yLDIxLjEydjUwLjY5aC0xNi4xM3YtNDYuMjFjMC03Ljk0LTMuNDYtMTEuNzgtOS43My0xMS43OC01LjUsMC0xMS4zOSw0Ljg2LTE0LjcyLDExLjl2NDYuMDhoLTE1Ljg3di00Ni4yMWMwLTguMDYtMy4wNy0xMS43OC04LjctMTEuNzhzLTExLjY1LDQuNzQtMTUuMjMsMTEuOXY0Ni4wOGgtMTUuODd2LTcwLjI3aDE1LjM2djEyLjI5WiIvPgogICAgPHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNTk4LjE4LDU0OC4yMmMtNS41LDE2LjEzLTEzLjk1LDIyLjE1LTI4LjI5LDIyLjE1LTIuNjksMC01LjM4LS4xMy04LjcxLS42NGwtLjY0LTEyLjI5YzMuNDYuNjQsNi4xNC45LDguOTYuOSw2LjUzLDAsMTAuODgtMy40NiwxMy4zMS0xMC44OGwxLjAyLTMuMDctMjMuODEtNjloMTcuMDNsOC4zMiwyOS40NGMyLjMsOC4wNiwzLjg0LDE0Ljg1LDUuODksMjMuMDRoMS4yOGMyLjE4LTcuOTQsMy45Ny0xNS4xLDYuMjctMjMuM2w4LjA2LTI5LjE5aDE2bC0yNC43MSw3Mi44M1oiLz4KICA8L2c+Cjwvc3ZnPg=='
};
  
// Inline thumbnails (SVG) provided via ZIP (embed as data URIs).
// If an SVG is present for a seat, use it; otherwise fall back to procedural render.
function getThumbForSeat(seat){
  try{
    if (typeof THUMBS_SVG !== 'undefined' && THUMBS_SVG && THUMBS_SVG[seat]) {
      return THUMBS_SVG[seat];
    }
  }catch(_){}
  return null;
}



    function buildThumbs(){
      const grid=document.getElementById('thumbgrid'); grid.innerHTML='';
      seatOrder.forEach((seat,i)=>{
        const brushId=seatToBrush[seat] || 'brush.empty';
        const btn=document.createElement('button'); btn.className='thumb'; btn.type='button'; btn.dataset.seat=seat; btn.dataset.index=String(i);
        btn.setAttribute('aria-label', seat);
        try{ const svg = getThumbForSeat(seat); if(svg){ btn.style.backgroundImage = 'url('+svg+')'; } else { const img=renderThumbForBrush(brushId); if(img) btn.style.backgroundImage='url('+img+')'; } }catch(_ ){} 
        /* seat label removed per request */
        attachSeatHandlers(btn, i);
        grid.appendChild(btn);
      });
      setActiveSeat(0);
    }

    // ===== Helper: analysis & sampling on polyline =====
    function analyzePath(path){
      const n=path.length; if(n<2) return {L:0,cumD:[0],cumT:[0],segV:[0],segUx:[1],segUy:[0]};
      const cumD=new Array(n).fill(0), cumT=new Array(n).fill(0);
      const segV=new Array(n-1).fill(0), segUx=new Array(n-1).fill(1), segUy=new Array(n-1).fill(0);
      for(let i=1;i<n;i++){
        const a=path[i-1], b=path[i];
        const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy);
        const dt=Math.max(1, (b.t && a.t)? (b.t-a.t) : 16);
        cumD[i]=cumD[i-1]+d; cumT[i]=cumT[i-1]+dt;
        if(d>0){ segUx[i-1]=dx/d; segUy[i-1]=dy/d; }
        segV[i-1]= (d / (dt/1000)); // px/s
      }
      return {
        L:cumD[n-1], cumD, cumT, segV, segUx, segUy,
        sampleAt(s){
          const L=this.L; if(!(L>0)) return {x:path[0].x,y:path[0].y,tx:1,ty:0,v:0,seg:0,tGlob:0};
          if(s<=0) return {x:path[0].x,y:path[0].y,tx:segUx[0],ty:segUy[0],v:segV[0], seg:0, tGlob:0};
          if(s>=L) return {x:path[n-1].x,y:path[n-1].y,tx:segUx[n-2],ty:segUy[n-2],v:segV[n-2], seg:n-2, tGlob:1};
          let i=1; while(i<n && cumD[i]<s) i++;
          const i0=i-1; const segLen = (cumD[i]-cumD[i0])||1;
          const r=(s-cumD[i0])/segLen;
          const ax=path[i0].x, ay=path[i0].y, bx=path[i].x, by=path[i].y;
          const x=ax+(bx-ax)*r, y=ay+(by-ay)*r;
          return {x,y,tx:segUx[i0],ty:segUy[i0],v:segV[i0],seg:i0, tGlob: s/L};
        }
      };
    }
    function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }
    function envelope(t){ const b = 1 - Math.abs(2*t - 1); return clamp(0.65 + 0.35*b, 0, 1); }
    // D10-specific envelope (A案): E_min=0.30, mild shaping ^1.35
    function envD10(t){
      const b = 1 - Math.abs(2*t - 1);
      const shaped = Math.pow(b, 1.35);
      return clamp(0.30 + 0.70*shaped, 0, 1);
    }


    // ===== utility fallbacks =====
    function simpleStrokePath(path, w){ if(!path||path.length<2) return;
      ctx.save(); resetStrokeState(ctx); ctx.lineWidth=w||2; ctx.strokeStyle='#000';
      ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for(let i=1;i<path.length;i++){ const q=path[i]; ctx.lineTo(q.x,q.y); } ctx.stroke(); ctx.restore();
    }
    function simplePreview(a,b){ previewOverlaySegment(a,b); }

    // ===== A3 minimal: live overlay & finish commit =====
    function overlayDashA3(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) { clearOverlay(); return; }
      const s=cfg.dash||{};
      const Lmin=s.Lmin||6, Lmax=s.Lmax||22, Pmin=s.Pmin||18, Pmax=s.Pmax||42;
      const MHEAD=s.marginHead||10, MTAIL=s.marginTail||10;
      const calibV = s.calibV||1600; // px/s

      const A=analyzePath(path); const L=A.L;
      ovctx.save(); resetStrokeState(ovctx); ovctx.lineWidth = ((currentCfg()?.width?.min)||1.2); ovctx.strokeStyle='#000'; ovctx.lineCap='butt';
      clearOverlay();
      if(!(L>0)){ ovctx.restore(); return; }
      const startS = Math.max(0, Math.min(L, MHEAD));
      const endS   = Math.max(startS, L - Math.max(0, MTAIL));

      let placed=0;
      let sPos = startS;
      while(sPos <= endS){
        const smp = A.sampleAt(sPos);
        const tLoc = (endS>startS) ? ((sPos - startS)/(endS - startS)) : 0.5;
        const E = envelope(tLoc);
        const dashLen = Lmin + (Lmax - Lmin)*E;
        const v = smp.v||0; const speedN = clamp(v/(calibV||1600), 0, 1);
        const pitch = Pmin + (Pmax - Pmin)*speedN;

        const hx = smp.tx, hy = smp.ty;
        const x0 = smp.x - hx*(dashLen/2), y0 = smp.y - hy*(dashLen/2);
        const x1 = smp.x + hx*(dashLen/2), y1 = smp.y + hy*(dashLen/2);

        ovctx.beginPath(); ovctx.moveTo(x0,y0); ovctx.lineTo(x1,y1); ovctx.stroke();
        placed++;
        sPos += Math.max(4, pitch);
      }

      if(placed===0){
        const smp = A.sampleAt((startS+endS)/2);
        const dashLen = (Lmin+Lmax)/2;
        const hx = smp.tx, hy = smp.ty;
        const x0 = smp.x - hx*(dashLen/2), y0 = smp.y - hy*(dashLen/2);
        const x1 = smp.x + hx*(dashLen/2), y1 = smp.y + hy*(dashLen/2);
        ovctx.beginPath(); ovctx.moveTo(x0,y0); ovctx.lineTo(x1,y1); ovctx.stroke();
      }

      ovctx.restore();
    }
    function commitDashA3(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      const s=cfg.dash||{};
      const Lmin=s.Lmin||6, Lmax=s.Lmax||22, Pmin=s.Pmin||18, Pmax=s.Pmax||42;
      const MHEAD=s.marginHead||10, MTAIL=s.marginTail||10;
      const calibV = s.calibV||1600;
      const A=analyzePath(path); const L=A.L;
      if(!(L>0)) return;
      const startS = Math.max(0, Math.min(L, MHEAD));
      const endS   = Math.max(startS, L - Math.max(0, MTAIL));
      ctx.save(); resetStrokeState(ctx); ctx.lineWidth = ((currentCfg()?.width?.min)||1.2); ctx.strokeStyle='#000'; ctx.lineCap='butt';
      let placed=0;
      let sPos = startS;
      while(sPos <= endS){
        const smp = A.sampleAt(sPos);
        const tLoc = (endS>startS) ? ((sPos - startS)/(endS - startS)) : 0.5;
        const E = envelope(tLoc);
        const dashLen = Lmin + (Lmax - Lmin)*E;
        const v = smp.v||0; const speedN = clamp(v/(calibV||1600), 0, 1);
        const pitch = Pmin + (Pmax - Pmin)*speedN;

        const hx = smp.tx, hy = smp.ty;
        const x0 = smp.x - hx*(dashLen/2), y0 = smp.y - hy*(dashLen/2);
        const x1 = smp.x + hx*(dashLen/2), y1 = smp.y + hy*(dashLen/2);

        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
        placed++;
        sPos += Math.max(4, pitch);
      }
      if(placed===0){
        const smp = A.sampleAt((startS+endS)/2);
        const dashLen = (Lmin+Lmax)/2;
        const hx = smp.tx, hy = smp.ty;
        const x0 = smp.x - hx*(dashLen/2), y0 = smp.y - hy*(dashLen/2);
        const x1 = smp.x + hx*(dashLen/2), y1 = smp.y + hy*(dashLen/2);
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
      }
      ctx.restore();
    }

    // ===== D10 minimal: live overlay & finish commit =====
    function overlayHatchD10(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) { clearOverlay(); return; }
      const h=cfg.hatch||{};
      const ANG=h.angle||Math.PI/4, Lmin=h.Lmin||6, Lmax=h.Lmax||18, Pmin=h.Pmin||16, Pmax=h.Pmax||36, OFF=h.offsetN||6;
      const calibV = h.calibV||1600;
      const A=analyzePath(path); const L=A.L;
      ovctx.save(); resetStrokeState(ovctx); ovctx.lineWidth=1; ovctx.strokeStyle='#000'; ovctx.lineCap='butt';
      clearOverlay();
      if(!(L>0)){ ovctx.restore(); return; }
      let sPos = 0, alt=0, placed=0;
      const hx=Math.cos(ANG), hy=Math.sin(ANG);

      while(sPos <= L){
        const smp = A.sampleAt(sPos);
        const tGlob = smp.tGlob||0;
        const E = envD10(tGlob);
        const len = Lmin + (Lmax - Lmin)*E;
        const off = ((alt&1)?1:-1) * OFF * (0.70 + 0.30*E);
        const nx = -smp.ty, ny = smp.tx;
        const cx = smp.x + nx*off, cy = smp.y + ny*off;
        const x0 = cx - hx*(len/2), y0 = cy - hy*(len/2);
        const x1 = cx + hx*(len/2), y1 = cy + hy*(len/2);
        ovctx.beginPath(); ovctx.moveTo(x0,y0); ovctx.lineTo(x1,y1); ovctx.stroke();
        placed++;
        const v = smp.v||0; const speedN = clamp(v/(calibV||1600), 0, 1);
        const pitch = Pmin + (Pmax - Pmin)*speedN;
        sPos += Math.max(4, pitch);
        alt++;
      }
      if(placed===0){
        const smp=A.sampleAt(L/2); const len=(Lmin+Lmax)/2;
        const x0=smp.x - Math.cos(ANG)*(len/2), y0=smp.y - Math.sin(ANG)*(len/2);
        const x1=smp.x + Math.cos(ANG)*(len/2), y1=smp.y + Math.sin(ANG)*(len/2);
        ovctx.beginPath(); ovctx.moveTo(x0,y0); ovctx.lineTo(x1,y1); ovctx.stroke();
      }
      ovctx.restore();
    }
    function commitHatchD10(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      const h=cfg.hatch||{};
      const ANG=h.angle||Math.PI/4, Lmin=h.Lmin||6, Lmax=h.Lmax||18, Pmin=h.Pmin||16, Pmax=h.Pmax||36, OFF=h.offsetN||6;
      const calibV = h.calibV||1600;
      const A=analyzePath(path); const L=A.L;
      if(!(L>0)) return;
      ctx.save(); resetStrokeState(ctx); ctx.lineWidth=1; ctx.strokeStyle='#000'; ctx.lineCap='butt';
      let sPos = 0, alt=0, placed=0;
      const hx=Math.cos(ANG), hy=Math.sin(ANG);

      while(sPos <= L){
        const smp = A.sampleAt(sPos);
        const tGlob = smp.tGlob||0;
        const E = envD10(tGlob);
        const len = Lmin + (Lmax - Lmin)*E;
        const off = ((alt&1)?1:-1) * OFF * (0.70 + 0.30*E);
        const nx = -smp.ty, ny = smp.tx;
        const cx = smp.x + nx*off, cy = smp.y + ny*off;
        const x0 = cx - hx*(len/2), y0 = cy - hy*(len/2);
        const x1 = cx + hx*(len/2), y1 = cy + hy*(len/2);
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
        placed++;
        const v = smp.v||0; const speedN = clamp(v/(calibV||1600), 0, 1);
        const pitch = Pmin + (Pmax - Pmin)*speedN;
        sPos += Math.max(4, pitch);
        alt++;
      }
      if(placed===0){
        const smp=A.sampleAt(L/2); const len=(Lmin+Lmax)/2;
        const x0=smp.x - Math.cos(ANG)*(len/2), y0=smp.y - Math.sin(ANG)*(len/2);
        const x1=smp.x + Math.cos(ANG)*(len/2), y1=smp.y + Math.sin(ANG)*(len/2);
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
      }
      ctx.restore();
    }

    // ===== band系 Overlay + Finish（既存） =====
    function path2dFromPts(path){ const p2=new Path2D(); p2.moveTo(path[0].x, path[0].y);
      for(let i=1;i<path.length;i++){ const q=path[i]; p2.lineTo(q.x, q.y); } return p2; }
    function path2dFromPtsOffset(path, dx, dy){ const p2=new Path2D(); p2.moveTo(path[0].x+dx, path[0].y+dy);
      for(let i=1;i<path.length;i++){ const q=path[i]; p2.lineTo(q.x+dx, q.y+dy); } return p2; }

    function overlayBandRim(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      const w=Math.max(1,Math.round(cfg.width.min)); const rimW=2;
      const p2=path2dFromPts(path);
      ovctx.save(); resetStrokeState(ovctx);
      ovctx.lineJoin='round'; ovctx.lineCap='round'; ovctx.setLineDash([]);
      ovctx.globalCompositeOperation='source-over'; ovctx.strokeStyle='rgba(0,0,0,0.35)'; ovctx.lineWidth=w; ovctx.stroke(p2);
      ovctx.globalCompositeOperation='destination-out'; ovctx.strokeStyle='#000'; ovctx.lineWidth=Math.max(1,w-2*rimW); ovctx.stroke(p2);
      ovctx.restore();
    }
    function overlayBand(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      const w=Math.max(1,Math.round(cfg.width.min));
      const al=Array.isArray((cfg.band||{}).alphas)? cfg.band.alphas : [0.15,0.35,0.6,0.95];
      const n=al.length-1; const denom=1+2*n; let base=Math.max(1,Math.floor(w/denom)), rem=w-base*denom;
      const centerH=base+(rem>0?1:0); if(rem>0) rem-=1; const pairH=new Array(n).fill(base);
      for(let i=0;i<n&&rem>=2;i++){ pairH[i]+=1; rem-=2; }
      const sumPairs=k=>{ let s=0; for(let j=0;j<k;j++) s+=pairH[j]; return s; };
      const p2=path2dFromPts(path);
      ovctx.save(); resetStrokeState(ovctx);
      ovctx.globalCompositeOperation='source-over'; ovctx.strokeStyle='rgba(0,0,0,'+al[0]+')'; ovctx.lineWidth=centerH; ovctx.stroke(p2);
      for(let i=n;i>=1;i--){ const outerW=centerH+2*sumPairs(i), innerW=centerH+2*sumPairs(i-1);
        ovctx.globalCompositeOperation='source-over'; ovctx.strokeStyle='rgba(0,0,0,'+al[i]+')'; ovctx.lineWidth=outerW; ovctx.stroke(p2);
        ovctx.globalCompositeOperation='destination-out'; ovctx.strokeStyle='#000'; ovctx.lineWidth=innerW; ovctx.stroke(p2);
      }
      ovctx.restore();
    }
    function overlayBandFillCenter(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      const w=Math.max(1,Math.round(cfg.width.min));
      const al=Array.isArray((cfg.band||{}).alphas)? cfg.band.alphas : [0.15,0.35,0.6,0.95];
      const n=al.length-1; const denom=1+2*n; let base=Math.max(1,Math.floor(w/denom)), rem=w-base*denom;
      const centerH=base+(rem>0?1:0); if(rem>0) rem-=1; const pairH=new Array(n).fill(base);
      for(let i=0;i<n&&rem>=2;i++){ pairH[i]+=1; rem-=2; }
      const sumPairs=k=>{ let s=0; for(let j=0;j<k;j++) s+=pairH[j]; return s; };
      const p2=path2dFromPts(path);
      ovctx.save(); resetStrokeState(ovctx);
      ovctx.globalCompositeOperation='source-over'; ovctx.strokeStyle='rgba(0,0,0,'+al[0]+')'; ovctx.lineWidth=centerH; ovctx.stroke(p2);
      for(let i=n;i>=1;i--){ const outerW=centerH+2*sumPairs(i), innerW=centerH+2*sumPairs(i-1);
        ovctx.globalCompositeOperation='source-over'; ovctx.strokeStyle='rgba(0,0,0,'+al[i]+')'; ovctx.lineWidth=outerW; ovctx.stroke(p2);
        ovctx.globalCompositeOperation='destination-out'; ovctx.strokeStyle='#000'; ovctx.lineWidth=innerW; ovctx.stroke(p2);
      }
      const centerAlpha = (al[1]!=null? al[1] : (al[0]!=null? al[0] : 0.30));
      ovctx.globalCompositeOperation='source-over'; ovctx.strokeStyle='rgba(0,0,0,'+centerAlpha+')'; ovctx.lineWidth=centerH; ovctx.stroke(p2);
      ovctx.restore();
    }

    function _bboxPadFromPath(path, pad){
      let minX=path[0].x, minY=path[0].y, maxX=path[0].x, maxY=path[0].y;
      for(let i=1;i<path.length;i++){ const p=path[i]; if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
      minX=Math.floor(minX-pad); minY=Math.floor(minY-pad); maxX=Math.ceil(maxX+pad); maxY=Math.ceil(maxY+pad);
      return {minX,minY,maxX,maxY,W:Math.max(1,(maxX-minX)|0),H:Math.max(1,(maxY-minY)|0)};
    }
    function _commitOffscreen(off, x, y){
      ctx.save(); ctx.setTransform(1,0,0,1,0,0); resetStrokeState(ctx); ctx.drawImage(off, Math.round(x*dpr), Math.round(y*dpr)); ctx.restore();
    }

    function bandRimPath(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      const w=Math.max(1,Math.round(cfg.width.min)); const rimW=2;
      const bb=_bboxPadFromPath(path, Math.ceil(w*1.4));
      const off=document.createElement('canvas'); off.width=Math.floor(bb.W*dpr); off.height=Math.floor(bb.H*dpr);
      const g=off.getContext('2d'); g.setTransform(dpr,0,0,dpr,0,0); resetStrokeState(g);
      const p2=path2dFromPtsOffset(path, -bb.minX, -bb.minY);
      g.save();
      g.lineJoin='round'; g.lineCap='round'; g.setLineDash([]);
      g.globalCompositeOperation='source-over'; g.strokeStyle='rgba(0,0,0,0.35)'; g.lineWidth=w; g.stroke(p2);
      g.globalCompositeOperation='destination-out'; g.strokeStyle='#000'; g.lineWidth=Math.max(1,w-2*rimW); g.stroke(p2);
      g.restore();
      _commitOffscreen(off, bb.minX, bb.minY);
    }
    function bandPath(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      const w=Math.max(1,Math.round(cfg.width.min));
      const al=Array.isArray((cfg.band||{}).alphas)? cfg.band.alphas : [0.15,0.35,0.6,0.95];
      const n=al.length-1; const denom=1+2*n; let base=Math.max(1,Math.floor(w/denom)), rem=w-base*denom;
      const centerH=base+(rem>0?1:0); if(rem>0) rem-=1; const pairH=new Array(n).fill(base);
      for(let i=0;i<n&&rem>=2;i++){ pairH[i]+=1; rem-=2; }
      const sumPairs=k=>{ let s=0; for(let j=0;j<k;j++) s+=pairH[j]; return s; };
      const bb=_bboxPadFromPath(path, Math.ceil(w*1.4));
      const off=document.createElement('canvas'); off.width=Math.floor(bb.W*dpr); off.height=Math.floor(bb.H*dpr);
      const g=off.getContext('2d'); g.setTransform(dpr,0,0,dpr,0,0); resetStrokeState(g);
      const p2=path2dFromPtsOffset(path, -bb.minX, -bb.minY);
      g.save(); g.lineJoin='round'; g.lineCap='round'; g.setLineDash([]);
      g.globalCompositeOperation='source-over'; g.strokeStyle='rgba(0,0,0,'+al[0]+')'; g.lineWidth=centerH; g.stroke(p2);
      for(let i=n;i>=1;i--){ const outerW=centerH+2*sumPairs(i), innerW=centerH+2*sumPairs(i-1);
        g.globalCompositeOperation='source-over'; g.strokeStyle='rgba(0,0,0,'+al[i]+')'; g.lineWidth=outerW; g.stroke(p2);
        g.globalCompositeOperation='destination-out'; g.strokeStyle='#000'; g.lineWidth=innerW; g.stroke(p2);
      }
      g.restore();
      _commitOffscreen(off, bb.minX, bb.minY);
    }
    function bandPathFillCenter(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      const w=Math.max(1,Math.round(cfg.width.min));
      const al=Array.isArray((cfg.band||{}).alphas)? cfg.band.alphas : [0.15,0.35,0.6,0.95];
      const n=al.length-1; const denom=1+2*n; let base=Math.max(1,Math.floor(w/denom)), rem=w-base*denom;
      const centerH=base+(rem>0?1:0); if(rem>0) rem-=1; const pairH=new Array(n).fill(base);
      for(let i=0;i<n&&rem>=2;i++){ pairH[i]+=1; rem-=2; }
      const sumPairs=k=>{ let s=0; for(let j=0;j<k;j++) s+=pairH[j]; return s; };
      const bb=_bboxPadFromPath(path, Math.ceil(w*1.4));
      const off=document.createElement('canvas'); off.width=Math.floor(bb.W*dpr); off.height=Math.floor(bb.H*dpr);
      const g=off.getContext('2d'); g.setTransform(dpr,0,0,dpr,0,0); resetStrokeState(g);
      const p2=path2dFromPtsOffset(path, -bb.minX, -bb.minY);
      g.save(); g.lineJoin='round'; g.lineCap='round'; g.setLineDash([]);
      g.globalCompositeOperation='source-over'; g.strokeStyle='rgba(0,0,0,'+al[0]+')'; g.lineWidth=centerH; g.stroke(p2);
      for(let i=n;i>=1;i--){ const outerW=centerH+2*sumPairs(i), innerW=centerH+2*sumPairs(i-1);
        g.globalCompositeOperation='source-over'; g.strokeStyle='rgba(0,0,0,'+al[i]+')'; g.lineWidth=outerW; g.stroke(p2);
        g.globalCompositeOperation='destination-out'; g.strokeStyle='#000'; g.lineWidth=innerW; g.stroke(p2);
      }
      const centerAlpha = (al[1]!=null? al[1] : (al[0]!=null? al[0] : 0.30));
      g.globalCompositeOperation='source-over'; g.strokeStyle='rgba(0,0,0,'+centerAlpha+')'; g.lineWidth=centerH; g.stroke(p2);
      g.restore();
      _commitOffscreen(off, bb.minX, bb.minY);
    }

    // ===== segOutline finish（保守用） =====
    function segLinesOutlinePath(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      const w=Math.max(1,Math.round((cfg.width&&cfg.width.min)||24));
      let totalLen=0;
      for(let i=1;i<path.length;i++){ const p0=path[i-1], p1=path[i]; totalLen += Math.hypot(p1.x-p0.x,p1.y-p0.y); }
      if(!(totalLen>0)) return;
      const baseStep = Math.max(12, Math.round(w*1.20));
      const baseSeg  = Math.max(6,  Math.round(w*0.80));
      function bell(t){ return 1 - Math.abs(2*t - 1); }
      function timeMul(t){ const u=(1.0 + 1.6*bell(t)); const endPull=(1.0 - 0.45*t); return Math.min(3.0, Math.max(0.50, u*endPull)); }
      function lenMul(t){ return 0.7 + 1.3*bell(t); }
      function speedMul(v){ if(!isFinite(v)||v<=0) return 0.8; if(v<400) return 0.85; if(v>1600) return 1.25; return 1.0 + 0.25*(v-400)/1200; }
      function pressureMul(p){ if(!(p>0)) return 1.0; return 1.05 - 0.3*Math.min(1, Math.max(0, (p-0.2)/0.6)); }
      const samples=[]; let remain=0, accLen=0;
      for(let i=1;i<path.length;i++){
        const a=path[i-1], b=path[i];
        let segLen=Math.hypot(b.x-a.x,b.y-a.y); if(!(segLen>0)) continue;
        const dt=(b.t && a.t)? Math.max(1,(b.t-a.t)) : 16;
        const v=segLen/(dt/1000); const pAvg=((a.p||0.5)+(b.p||0.5))*0.5;
        const tx=(b.x-a.x)/segLen, ty=(b.y-a.y)/segLen; let t=0;
        while(t<segLen){
          const tGlob=(accLen+t)/totalLen;
          const step = baseStep * timeMul(tGlob) * speedMul(v) * pressureMul(pAvg);
          const dtStep=Math.max(1, step - remain); t+=dtStep;
          if(t>segLen){ remain = step - (dtStep - (t-segLen)); break; }
          samples.push({x:a.x+tx*t, y:a.y+ty*t, tGlob, v, p:pAvg});
          remain=0;
        }
        accLen+=segLen;
      }
      if(!samples.length){ const q=path[path.length-1]; samples.push({x:q.x,y:q.y,tGlob:1,v:0,p:1}); }
      let minX=path[0].x, maxX=path[0].x, minY=path[0].y, maxY=path[0].y;
      for(let i=1;i<path.length;i++){ const p=path[i]; if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
      const pad=Math.ceil(w*1.4);
      minX=Math.floor(minX-pad); minY=Math.floor(minY-pad); maxX=Math.ceil(maxX+pad); maxY=Math.ceil(maxY+pad);
      const W=Math.max(1,(maxX-minX)|0), H=Math.max(1,(maxY-minY)|0);
      const off=document.createElement('canvas'); off.width=Math.max(1,Math.floor(W*dpr)); off.height=Math.max(1,Math.floor(H*dpr));
      const g=off.getContext('2d'); g.setTransform(dpr,0,0,dpr,0,0); resetStrokeState(g);
      g.save(); g.lineJoin='miter'; g.lineCap='butt'; g.strokeStyle='#000'; g.lineWidth=2;
      function dirAt(idx){ const prev=samples[Math.max(0,idx-1)], next=samples[Math.min(samples.length-1,idx+1)];
        let dx=(next.x-prev.x), dy=(next.y-prev.y); const L=Math.hypot(dx,dy)||1; dx/=L; dy/=L; return {tx:dx, ty:dy, nx:-dy, ny:dx}; }
      for(let i=0;i<samples.length;i++){
        const p=samples[i]; const {tx,ty,nx,ny}=dirAt(i); const side=(i%2===0)?1:-1;
        const offN=side*(w*0.30 + (Math.random()*0.16 - 0.08)*w);
        const cx=p.x - minX + nx*offN, cy=p.y - minY + ny*offN;
        const segLen=baseSeg * lenMul(p.tGlob);
        const x0=cx-(tx*segLen/2), y0=cy-(ty*segLen/2);
        const x1=cx+(tx*segLen/2), y1=cy+(ty*segLen/2);
        g.beginPath(); g.moveTo(x0,y0); g.lineTo(x1,y1); g.stroke();
      }
      g.restore();
      const p2=new Path2D(); p2.moveTo(path[0].x-minX, path[0].y-minY); for(let i=1;i<path.length;i++){ const q=path[i]; p2.lineTo(q.x-minX, q.y-minY); }
      const envW=Math.max(2,Math.round(w));
      g.save(); g.globalCompositeOperation='destination-in'; g.lineJoin='round'; g.lineCap='round'; g.strokeStyle='#000'; g.lineWidth=envW; g.stroke(p2); g.restore();
      _commitOffscreen(off, minX, minY);
    }

    // ===== D11（G21） finish: hatch realtime → commit =====
    function drawDiagHatchFinishPath(path){
      const cfg=currentCfg(); if(!cfg||!path||path.length<2) return;
      ensureBrushState(cfg);
      ctx.save(); resetStrokeState(ctx);
      ctx.lineCap='butt'; ctx.lineJoin='miter'; ctx.strokeStyle='#000'; ctx.lineWidth=1;
      const S = (cfg._state = cfg._state || {});
      if (typeof S.hatchResid !== 'number' || S.hatchResid < 0) S.hatchResid = 8;
      if (typeof S.hatchAlt !== 'number') S.hatchAlt = 0;

      for(let i=1;i<path.length;i++){
        const a=path[i-1], b=path[i];
        const dx=b.x-a.x, dy=b.y-a.y; const dist=Math.hypot(dx,dy); if(!(dist>0)) continue;
        const dt=(b.t && a.t)? Math.max(1,(b.t-a.t)) : 16;
        const v = dist/(dt/1000);
        const pAvg=((a.p||0.5)+(b.p||0.5))*0.5;
        const w = 12;
        const basePitch = Math.max(6, Math.round(w*0.9));
        const baseLen   = Math.max(4, Math.round(w*0.8));
        function speedMul(v){ if(!isFinite(v) || v<=0) return 0.95; if(v<400) return 1.00; if(v>1800) return 1.28; return 1.0 + 0.28*(v-400)/1400; }
        function pressureMul(p){ if(!(p>0)) return 1.0; return 1.05 - 0.3*Math.min(1, Math.max(0, (p-0.2)/0.6)); }
        const pitch = basePitch * speedMul(v) * pressureMul(pAvg);
        const ux = dx/dist, uy = dy/dist; const nx = -uy, ny = ux;
        let remain = dist, tLocal = 0, resid = S.hatchResid;
        const ang = Math.PI/4; const hx=Math.cos(ang), hy=Math.sin(ang);
        while(remain >= resid){
          tLocal += resid;
          const cx = a.x + ux*tLocal, cy = a.y + uy*tLocal;
          const segLen = baseLen * (0.9 + Math.random()*0.2);
          const sideSign = (S.hatchAlt & 1) ? 1 : -1;
          const offN = sideSign * (w*0.30) * (0.9 + Math.random()*0.2);
          const cxo = cx + nx*offN, cyo = cy + ny*offN;
          const hxv = hx*(segLen/2), hyv = hy*(segLen/2);
          ctx.beginPath(); ctx.moveTo(cxo - hxv, cyo - hyv); ctx.lineTo(cxo + hxv, cyo + hyv); ctx.stroke();
          S.hatchAlt++; remain -= resid; resid = pitch;
        }
        S.hatchResid = resid - remain;
      }
      ctx.restore();
    }

    // ====== kernels ======
    function sprinkleSegment(a,b){
      const cfg=currentCfg(); if(!cfg||!a||!b) return;
      ensureBrushState(cfg);
      const S = cfg._state;
      ctx.save(); resetStrokeState(ctx);
      ctx.strokeStyle='#000'; ctx.lineCap='round';
      const Rbase = Math.max(4,(cfg.width?.min||8));
      const R0 = Rbase * (0.95 + 0.10*Math.random());
      const dist = Math.max(1e-4,Math.hypot(b.x-a.x,b.y-a.y));
      const steps = Math.max(1,Math.floor(dist/Math.max(1,(cfg.spacingPx||2))));
      const tx=(b.x-a.x)/dist, ty=(b.y-a.y)/dist; const nAng = Math.atan2(-tx,ty);
      const lenMin = ((cfg.sprinkles&&cfg.sprinkles.lenMin)|0)||4;
      const lenMax = ((cfg.sprinkles&&cfg.sprinkles.lenMax)|0)||16;

      let emitted = 0;
      for(let i=1;i<=steps;i++){
        const t=i/steps; const e=1 - Math.abs(1 - 2*t); const edgeW=Math.pow(e,3.2);
        let voidP=0.60 - 0.55*edgeW;
        if(steps<=2 || i===1 || i===steps) voidP *= 0.35;

        if(Math.random()<voidP) continue;
        const cx=a.x+tx*dist*t, cy=a.y+ty*dist*t;
        const Rstep = R0 * (0.90 + 0.20*Math.random());
        const baseDrops=4;
        let p = Math.min(0.32, 0.035 + 0.24*edgeW);
        if(steps<=2 || i===1 || i===steps) p = Math.max(p, 0.22);

        for(let k=0;k<baseDrops;k++){
          if(Math.random()>p) continue;
          const rim = Math.random()<0.60;
          const rr = rim ? Rstep*(0.88 + 0.16*Math.random()) : Rstep*Math.sqrt(Math.random());
          let th = Math.random()*Math.PI*2;
          const d = Math.abs(Math.atan2(Math.sin(th-nAng), Math.cos(th-nAng)));
          if(d > Math.PI/2 && Math.random()<0.6) continue;
          const x=cx+rr*Math.cos(th), y=cy+rr*Math.sin(th);
          const uL=Math.random(); let L; if(uL<0.7){ const v=Math.random(); L = lenMin + (lenMax-lenMin)*Math.pow(v,3.0); } else { const v=Math.random(); const base=lenMin+4; L = base + (lenMax-base)*Math.pow(v,0.5); }
          const ang = Math.random()*Math.PI*2;
          ctx.lineWidth=1;
          ctx.beginPath(); ctx.moveTo(Math.round(x),Math.round(y));
          ctx.lineTo(Math.round(x + L*Math.cos(ang)), Math.round(y + L*Math.sin(ang)));
          ctx.stroke();
          emitted++;
        }
      }

      if(emitted===0){
        const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2;
        const L = Math.max(3, lenMin);
        const ang = Math.random()*Math.PI*2;
        ctx.beginPath(); ctx.moveTo(Math.round(cx),Math.round(cy));
        ctx.lineTo(Math.round(cx + L*Math.cos(ang)), Math.round(cy + L*Math.sin(ang)));
        ctx.stroke();
        emitted=1;
      }
      S.sprinkleEmit = (S.sprinkleEmit|0) + emitted;
      ctx.restore();
    }

    function spraySegment(a,b){
      const cfg=currentCfg(); if(!cfg||!a||!b) return;
      ensureBrushState(cfg);
      ctx.save(); resetStrokeState(ctx);
      ctx.fillStyle = '#000';
      const Rbase = Math.max(4,(cfg.width?.min||8));
      const R0 = Rbase * (0.95 + 0.10*Math.random());
      const dist = Math.max(1e-4,Math.hypot(b.x-a.x,b.y-a.y));
      const steps = Math.max(1,Math.floor(dist/Math.max(1,(cfg.spacingPx||2))));
      const tx=(b.x-a.x)/dist, ty=(b.y-a.y)/dist; const nAng = Math.atan2(-tx,ty);
      const sideSign = (currentCfg()?._state?.spraySide) ?? 1;
      for(let i=1;i<=steps;i++){
        if(Math.random()<0.35) continue;
        const localSide = (Math.random()<0.08) ? -sideSign : sideSign;
        const t=i/steps, cx=a.x+tx*dist*t, cy=a.y+ty*dist*t;
        const Rstep = R0 * (0.90 + 0.20*Math.random());
        const sectorOn = Math.random()<0.25;
        const sectorCenter = sectorOn ? Math.random()*Math.PI*2 : 0;
        const sectorWidth  = sectorOn ? (0.30 + Math.random()*0.70) : 0;
        const baseDrops = 12;
        const u = Math.random();
        const p = 0.03 + (u*u)*0.22;
        for(let k=0;k<baseDrops;k++){
          if(Math.random()>p) continue;
          const outerBias = Math.random()<0.70;
          let rr = outerBias ? Rstep * (0.90 + 0.22*Math.random())
                             : Rstep * Math.sqrt(Math.random());
          let th = Math.random()*Math.PI*2;
          const targetAng = (localSide>0 ? nAng : nAng+Math.PI);
          const d = Math.abs(Math.atan2(Math.sin(th-targetAng), Math.cos(th-targetAng)));
          if(d > Math.PI/2 && Math.random()<0.75) continue;
          if(sectorOn){
            const d2 = Math.abs(Math.atan2(Math.sin(th-sectorCenter), Math.cos(th-sectorCenter)));
            if(d2 < sectorWidth*0.5) continue;
          }
          const push = (outerBias? 1.5:0.5) * (0.5 + Math.random());
          const x=cx + (rr+push)*Math.cos(th), y=cy + (rr+push)*Math.sin(th);
          const r = Math.random(); const sz = (r<0.12?3:(r<0.37?1:2));
          ctx.fillRect(Math.round(x),Math.round(y),sz,sz);
        }
      }
      ctx.restore();
    }

    function drawSnowSquaresSegment(a,b){
      const cfg=currentCfg(); if(!cfg) return;
      ensureBrushState(cfg);
      ctx.save(); resetStrokeState(ctx);
      const S = (cfg._state = cfg._state || {});
      if(typeof S.snowP!=='number') S.snowP = 0.48;
      const dot = Math.max(2, (cfg.snow && cfg.snow.dot)|0 || 8);
      const dist = Math.max(1e-4, Math.hypot(b.x-a.x,b.y-a.y));
      const dt   = Math.max(1e-4, (b.t-a.t));
      const spN  = Math.max(0, Math.min(1, (dist/dt)/1.6));
      const baseR= 14 + 28*spN;
      const steps= Math.max(1, Math.floor(dist/Math.max(1,(cfg.spacingPx||2))));
      const ux=(b.x-a.x)/dist, uy=(b.y-a.y)/dist;
      const minGapBase = Math.round(dot*2.6);
      const key=(ix,iy)=>ix+','+iy;
      const allowed=(x,y,minGap)=>{ const ix=Math.floor(x/minGap), iy=Math.floor(y/minGap); const min2=(minGap*0.9)*(minGap*0.9);
        for(let dx=-1;dx<=1;dx++){ for(let dy=-1;dy<=1;dy++){ const arr=S.occSnow.get(key(ix+dx,iy+dy)); if(!arr) continue;
          for(let i=0;i<arr.length;i++){ const p=arr[i]; const dx2=x-p.x, dy2=y-p.y; if(dx2*dx2+dy2*dy2<min2) return false; } } }
        return true; };
      const record=(x,y,minGap)=>{ const ix=Math.floor(x/minGap), iy=Math.floor(y/minGap); const k=key(ix,iy); const arr=S.occSnow.get(k)||[]; arr.push({x,y}); S.occSnow.set(k,arr); };
      for(let i=1;i<=steps;i++){
        const t=i/steps; const cx=a.x+ux*dist*t, cy=a.y+uy*dist*t;
        const e = 1 - Math.abs(1 - 2*t); const edgeW = Math.pow(e, 4.6);
        const keepStep = (edgeW > 0.90) || (Math.random() < edgeW * 0.12); if(!keepStep) continue;
        let nominal = (0.2 + 11.0*edgeW) * (0.7 + 0.5*spN) * (0.55 + 1.0*Math.random()); if(edgeW < 0.35) nominal *= 0.25;
        if (edgeW > 0.95 && Math.random() < 0.5) nominal += 6 + Math.floor(Math.random()*5);
        let drops = Math.max(1, Math.round(nominal * S.snowP));
        for(let k=0;k<drops;k++){
          const R  = baseR * (0.85 + 0.55*Math.random());
          const rr = R * Math.sqrt(Math.random());
          const th = Math.random()*Math.PI*2;
          const jx = (Math.random()*2-1) * (0.9 + 0.7*Math.random());
          const jy = (Math.random()*2-1) * (0.9 + 0.7*Math.random());
          const x  = Math.round(cx + rr*Math.cos(th) + jx);
          const y  = Math.round(cy + rr*Math.sin(th) + jy);
          const minGap = Math.max(2, Math.round(minGapBase * (0.70 + 0.40*Math.random()) * (0.50 + 1.1*(1-edgeW)) ));
          if(!allowed(x,y,minGap)) continue;
          record(x,y,minGap);
          ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.strokeRect(x+0.5,y+0.5,dot-1,dot-1);
        }
      }
      ctx.restore();
    }

    function drawDebrisSegment(a,b){
      const cfg=currentCfg(); if(!cfg) return;
      ctx.save(); resetStrokeState(ctx);
      const dens=0.06, nMin=3, nMax=6, eMin=1, eMax=3, selfP=0.7, fillP=0.45, aniso=0.4, sRad=80;
      const dist=Math.max(1e-4,Math.hypot(b.x-a.x,b.y-a.y));
      const steps=Math.max(1,Math.floor(dist/Math.max(1,(cfg.spacingPx||2))));
      const ux=(b.x-a.x)/dist, uy=(b.y-a.y)/dist;
      for(let i=1;i<=steps;i++){ const t=i/steps; const cx0=a.x+ux*dist*t, cy0=a.y+uy*dist*t;
        const rr=(2+Math.random()*sRad)*Math.sqrt(Math.random()); const th0=Math.random()*Math.PI*2;
        const cx=cx0+rr*Math.cos(th0), cy=cy0+rr*Math.sin(th0);
        const expected=((eMax+eMin)/2)*dens; let count=Math.floor(expected); if(Math.random()<(expected-count)) count++;
        for(let k=0;k<count;k++){ const n=Math.floor(Math.random()*(nMax-nMin+1))+nMin; const edge=eMin+Math.random()*(eMax-eMin);
          const R=edge, ax=1+aniso*Math.random(), ay=1+aniso*Math.random();
          const angBase=Math.random()*Math.PI*2, stepAng=(Math.PI*2)/n; const poly=[];
          for(let j=0;j<n;j++){ const th=angBase+j*stepAng+(Math.random()*2-1)*0.6; let rx=R+(Math.random()*2-1)*1.2; if(rx<0.5) rx=0.5;
            poly.push({x:Math.round(cx+Math.cos(th)*rx*ax), y:Math.round(cy+Math.sin(th)*rx*ay)});
          }
          if(Math.random()<selfP){
            if(n>=5 && Math.random()<0.55){ const kstep=(n>=7&&Math.random()<0.3)?3:2; const p=[]; for(let r=0;r<n;r++){ p.push(poly[(r*kstep)%n]); } poly.splice(0,poly.length,...p); }
            else if(n===4 && Math.random()<0.5){ const p=[poly[0],poly[2],poly[1],poly[3]]; poly.splice(0,poly.length,...p); }
            else { const idx=Math.floor(Math.random()*n), v=poly[idx]; const vx=v.x-cx, vy=v.y-cy; const mul=3.0+Math.random()*0.6; v.x=Math.round(cx+vx*mul); v.y=Math.round(cy+vy*mul); }
          }
          if(Math.random()<fillP){ const pth=new Path2D(); pth.moveTo(poly[0].x,poly[0].y); for(let j=1;j<poly.length;j++){ pth.lineTo(poly[j].x,poly[j].y); } pth.closePath(); ctx.fillStyle='#000'; try{ ctx.fill(pth,'evenodd'); }catch(e){ ctx.fill(pth); } }
          else { ctx.save(); resetStrokeState(ctx); ctx.lineWidth=1; ctx.strokeStyle='#000'; ctx.beginPath(); ctx.moveTo(poly[0].x+0.5,poly[0].y+0.5); for(let j=1;j<poly.length;j++){ ctx.lineTo(poly[j].x+0.5,poly[j].y+0.5); } ctx.closePath(); ctx.stroke(); ctx.restore(); }
        }
      }
      ctx.restore();
    }

    function fillClosedPath(path, fillStyle){
      const p2=new Path2D();
      p2.moveTo(path[0].x, path[0].y);
      for(let i=1;i<path.length;i++){ const q=path[i]; p2.lineTo(q.x, q.y); }
      p2.closePath();
      ctx.save(); resetStrokeState(ctx);
      ctx.globalCompositeOperation='source-over';
      ctx.fillStyle = fillStyle || '#EAEAEA';
      try{ ctx.fill(p2, 'evenodd'); }catch(e){ ctx.fill(p2); }
      ctx.restore();
    }

    // ===== bigDots live overlay (F18) =====
    function overlayBigDotsRealtimeSegment(a,b){
      const cfg=currentCfg(); if(!cfg||!a||!b) return;
      ensureBrushState(cfg); const S = cfg._state;
      const s = cfg.bigdots || {};
      const R = Math.max(1, s.radiusPx || 40);
      const base = Math.max(10, s.basePitch || 144);
      const gain = (s.speedGain!=null? s.speedGain : 2.0);
      const curv = (s.speedCurve!=null? s.speedCurve : 2.4);
      const calib = (s.speedCalib!=null? s.speedCalib : 1.6);

      const dist = Math.max(1e-4, Math.hypot(b.x-a.x,b.y-a.y));
      const dt   = Math.max(1e-4, (b.t-a.t));
      let spN = Math.max(0, Math.min(1, (dist/dt)/calib)); spN = Math.pow(spN, curv);
      const ux=(b.x-a.x)/dist, uy=(b.y-a.y)/dist;

      if(typeof S.bigDotsDist!=='number') S.bigDotsDist=0;
      let t=0;

      ovctx.save(); resetStrokeState(ovctx);
      while(t<=dist){
        const edgeBoost = Math.exp(-S.bigDotsDist/160);
        let pitch = Math.max(36, base * (1 + gain * (0.45 + 0.55*spN)));
        pitch *= (1.30 + 0.50*Math.random()) * (0.60 + 0.40*(1-edgeBoost)) * (1.60 + 1.20*(1 - spN));
        const skipP = 0.20 + 0.40*(1 - edgeBoost);
        const keepPoint = Math.random() > skipP;
        if(keepPoint){
          const px=Math.round(a.x+ux*t), py=Math.round(a.y+uy*t);
          // record
          S.bigDotsCenters.push({x:px,y:py,R});
          // draw overlay ring
          ovctx.fillStyle='#000';
          ovctx.beginPath(); ovctx.arc(px,py,R,0,Math.PI*2); ovctx.fill();
          ovctx.globalCompositeOperation='destination-out';
          ovctx.beginPath(); ovctx.arc(px,py,Math.max(1,R-1),0,Math.PI*2); ovctx.fill();
          ovctx.globalCompositeOperation='source-over';
        }
        t += pitch; S.bigDotsDist += pitch;
      }
      ovctx.restore();
    }

    
    // ===== D10: hatch immediate（2列化防止版） =====
    function drawHatchD10minSegment(a,b){
      const cfg=currentCfg(); if(!cfg||!a||!b) return;
      ensureBrushState(cfg);
      const S = (cfg._state = cfg._state || {});
      const __tick = (window.__strokeTick|0);
      if(S.__tick__!==__tick){ S.__tick__=__tick; S.h_resid=0; S.h_i=0; S.prevOff=0; }

      const h = cfg.hatch || {};
      const ANG = (typeof h.angle==='number') ? h.angle : Math.PI/4;
      const Lmin = Math.max(4, h.Lmin||6);
      const Lmax = Math.max(Lmin, h.Lmax||18);
      const Pmin = Math.max(6, h.Pmin||16);
      const OFF  = Math.max(2, h.offsetN||6);

      const dx=b.x-a.x, dy=b.y-a.y; const dist=Math.hypot(dx,dy); if(!(dist>0)) return;
      const ux=dx/dist, uy=dy/dist;
      const nx=-uy, ny=ux;

      const pitch = Pmin;
      let remain=dist, tLocal=0, resid=(S.h_resid>0?S.h_resid:pitch);

      const hx=Math.cos(ANG), hy=Math.sin(ANG);
      function snap(v){ return Math.round(v)+0.5; }
      function jhash(n){ n=(n<<13)^n; return (1.0-((n*(n*n*15731+789221)+1376312589)&0x7fffffff)/1073741824.0); }
      function r01(i){ return (jhash((__tick*911 + i*31337)|0)+1)*0.5; }

      ctx.save(); resetStrokeState(ctx); ctx.lineWidth=1; ctx.strokeStyle='#000'; ctx.lineCap='butt';
      while(remain >= resid){
        tLocal += resid;
        S.h_i++;
        const cx = a.x + ux*tLocal, cy = a.y + uy*tLocal;

        const ph = (S.h_i*0.318)%1;
        const len = Lmin + (Lmax - Lmin) * (0.35 + 0.45*ph);

        const u = r01(S.h_i);
        let sgn = (r01(S.h_i+9999)<0.5)? -1 : 1;
        let tri = (u<0.5)? (2*u) : (2*(1-u));
        tri = (sgn<0? -tri: tri);
        if((S.h_i%5)===0) tri *= 0.3;
        const rawOff = tri * OFF;
        const off = S.prevOff*0.35 + rawOff*0.65;
        S.prevOff = off;

        const mx = cx + nx*off, my = cy + ny*off;
        const x0 = snap(mx - hx*(len/2)), y0 = snap(my - hy*(len/2));
        const x1 = snap(mx + hx*(len/2)), y1 = snap(my + hy*(len/2));
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();

        remain -= resid; resid = pitch;
      }
      S.h_resid = resid - remain;
      ctx.restore();
    }

    // ===== D12: Vertical stripes (immediate) =====
    function drawVerticalStripesD12Segment(a,b){
      const cfg=currentCfg(); if(!cfg||!a||!b) return;
      ensureBrushState(cfg);
      const S = (cfg._state = cfg._state || {});
      if(typeof S.vsResid!=='number') S.vsResid = 0;
      if(typeof S.vsIndex!=='number') S.vsIndex = 0;
      const vs = cfg.vstripes || {};
      const pitch = Math.max(16, (vs.pitch|0) || 30);
      const lenMin = Math.max(4, (vs.lenMin|0) || 12);
      const lenMax = Math.max(lenMin+1, (vs.lenMax|0) || 48);

      const dx=b.x-a.x, dy=b.y-a.y; const dist=Math.hypot(dx,dy); if(!(dist>0)) return;
      const ux=dx/dist, uy=dy/dist;

      let remain = dist, tLocal = 0, resid = (S.vsResid>0? S.vsResid : pitch);
      ctx.save(); resetStrokeState(ctx); ctx.lineWidth=1; ctx.strokeStyle='#000'; ctx.lineCap='butt';
      while(remain >= resid){
        tLocal += resid;
        const cx = a.x + ux*tLocal, cy = a.y + uy*tLocal;
        S.vsIndex++;
        const ph = 0.5 + 0.5*Math.sin(S.vsIndex*0.72);
        const rand = 0.70 + 0.30*Math.random();
        const L = lenMin + (lenMax - lenMin) * Math.min(1, 0.35 + 0.65*ph*rand);
        const x = Math.round(cx) + 0.5;
        const y0 = Math.round(cy - L*0.5) + 0.5;
        const y1 = Math.round(cy + L*0.5) + 0.5;
        ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y1); ctx.stroke();
        remain -= resid; resid = pitch;
      }
      S.vsResid = resid - remain;
      ctx.restore();
    }

    // ===== G20: Scatter of '×' marks (immediate) =====
    function drawCrossScatterG20Segment(a,b){
      const cfg=currentCfg(); if(!cfg||!a||!b) return;
      ensureBrushState(cfg);
      const S = (cfg._state = cfg._state || {});
      if(!(S.crossOcc instanceof Map)) S.crossOcc = new Map();

      const c = cfg.cross || {};
      const size = Math.max(2, (c.size|0) || 8);
      const half = size/2;
      const minGap = Math.max(4, (c.minGap|0) || Math.round(size*1.5));

      const dx=b.x-a.x, dy=b.y-a.y; const dist=Math.hypot(dx,dy); if(!(dist>0)) return;
      const ux=dx/dist, uy=dy/dist;

      const key=(ix,iy)=>ix+','+iy;
      const allowed=(x,y,g)=>{
        const ix=Math.floor(x/g), iy=Math.floor(y/g);
        const r2=(g*0.9)*(g*0.9);
        for(let dx=-1;dx<=1;dx++){
          for(let dy=-1;dy<=1;dy++){
            const arr=S.crossOcc.get(key(ix+dx,iy+dy)); if(!arr) continue;
            for(let i=0;i<arr.length;i++){ const p=arr[i]; const dx2=x-p.x, dy2=y-p.y; if(dx2*dx2+dy2*dy2<r2) return false; }
          }
        }
        return true;
      };
      const record=(x,y,g)=>{
        const ix=Math.floor(x/g), iy=Math.floor(y/g);
        const k=key(ix,iy); const arr=S.crossOcc.get(k)||[]; arr.push({x,y}); S.crossOcc.set(k,arr);
      };

      const steps = Math.max(1, Math.floor(dist/Math.max(1,(cfg.spacingPx||2))));
      ctx.save(); resetStrokeState(ctx); ctx.lineWidth=1; ctx.strokeStyle='#000'; ctx.lineCap='butt';
      for(let i=1;i<=steps;i++){
        const t=i/steps;
        const edge = 1 - Math.abs(1 - 2*t);
        let p = 0.12 + 0.10*edge;
        if(Math.random()>p) continue;
        const cx = a.x + ux*dist*t, cy = a.y + uy*dist*t;
        const x = Math.round(cx), y = Math.round(cy);
        if(!allowed(x,y,minGap)) continue;
        ctx.beginPath();
        ctx.moveTo(x - half + 0.5, y - half + 0.5);
        ctx.lineTo(x + half + 0.5, y + half + 0.5);
        ctx.moveTo(x - half + 0.5, y + half + 0.5);
        ctx.lineTo(x + half + 0.5, y - half + 0.5);
        ctx.stroke();
        record(x,y,minGap);
      }
      ctx.restore();
    }

    // ===== G21: Random Segments (360°), immediate =====
    function drawRandSegG21Segment(a,b){
      const cfg=currentCfg(); if(!cfg||!a||!b) return;
      ensureBrushState(cfg);
      const S = (cfg._state = cfg._state || {});
      if(typeof S.rsResid!=='number') S.rsResid=0;
      if(typeof S.rsIndex!=='number') S.rsIndex=0;
      const g = cfg.rseg || {};
      const basePitch = Math.max(12, (g.pitch|0) || 40);
      const lenScale  = Math.max(1.0, g.lenScale || 3.6);
      const Lbase = basePitch * lenScale;
      const fmin  = Math.max(0.25, Math.min(1.0, g.fracMin||0.5));
      const fmax  = Math.max(fmin, Math.min(1.0, g.fracMax||0.6667));
      const stepMul = Math.max(0.15, Math.min(0.8, g.stepMul||0.35));
      const stepLen = Math.max(6, Lbase * stepMul);

      function snap(v){ return Math.round(v)+0.5; }

      const dx=b.x-a.x, dy=b.y-a.y; const dist=Math.hypot(dx,dy); if(!(dist>0)) return;
      const ux=dx/dist, uy=dy/dist;

      let remain=dist, tLocal=0, resid=(S.rsResid>0? S.rsResid : stepLen);

      ctx.save(); resetStrokeState(ctx); ctx.lineWidth=1; ctx.strokeStyle='#000'; ctx.lineCap='butt'; ctx.lineJoin='miter'; ctx.miterLimit=2;
      while(remain >= resid){
        tLocal += resid;
        S.rsIndex++;
        const cx = a.x + ux*tLocal, cy = a.y + uy*tLocal;

        // 角度：0〜360°を純粋ランダム
        const ang = Math.random() * Math.PI * 2;
        // 長さ：旧G21基準 L の 1/2〜2/3
        const frac = fmin + (fmax - fmin) * Math.random();
        const half = 0.5 * Lbase * frac;

        const hx = Math.cos(ang) * half, hy = Math.sin(ang) * half;
        const x1 = snap(cx - hx), y1 = snap(cy - hy);
        const x2 = snap(cx + hx), y2 = snap(cy + hy);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

        remain -= resid; resid = stepLen;
      }
      S.rsResid = resid - remain;
      ctx.restore();
    }
// ======== 描画モード定義（base 単位） ========
    const RENDER_MODE = {
      'brush.band': 'liveBand',
      'brush.bandRim': 'liveBand',
      'brush.bandCenter': 'liveBand',
      'brush.bigDotsC9': 'liveDots',
      'brush.diagHatchD11': 'liveHatch',    // 既存(G21)
      'brush.hatchD10min': 'immediate',    // ★新設（パターン違い）
      'brush.dashA3': 'liveDash',           // ★新設（破線）

      'brush.fillGrayB6': 'finishOnly',
  'brush.vStripesD12': 'immediate',
  'brush.crossScatterG20': 'immediate',
  'brush.randSegG21': 'immediate'};
    function modeOf(base){ return RENDER_MODE[base] || 'immediate'; }

    // ===== Router & stroke control =====
    let drawing=false, pts=[]; let __rafPending=false, __drawIndex=0;

    const FINISH_PREVIEW_BASES = new Set(['brush.fillGrayB6']);

    function previewOverlaySegment(a,b){
      ovctx.save(); resetStrokeState(ovctx);
      ovctx.globalAlpha=0.30;
      ovctx.lineJoin='round'; ovctx.lineCap='round';
      ovctx.strokeStyle='#000'; ovctx.lineWidth=1;
      ovctx.beginPath(); ovctx.moveTo(a.x,a.y); ovctx.lineTo(b.x,b.y); ovctx.stroke();
      ovctx.restore();
    }

    function __flushDraw(){ __rafPending=false; if(!drawing) return; const end=pts.length-1; for(let i=__drawIndex;i<end;i++) drawSegment(pts[i], pts[i+1]); __drawIndex=end; }

    function drawSegment(a,b){
      try{
        if(!a||!b) return;
        if(__eraserActive){ eraseSegment(a,b); return; }

        const id=currentBrushId(); const base=baseOf(id);
        const isLast = (b===pts[pts.length-1]);

        resetStrokeState(ctx);

        const mode = modeOf(base);

        // ---- Live overlay 系 ----
        if(mode==='liveBand'){
          if(isLast){
            clearOverlay();
            if(base==='brush.bandRim'){ if(typeof overlayBandRim==='function') overlayBandRim(pts); else simplePreview(a,b); }
            else if(base==='brush.bandCenter'){ if(typeof overlayBandFillCenter==='function') overlayBandFillCenter(pts); else simplePreview(a,b); }
            else { if(typeof overlayBand==='function') overlayBand(pts); else simplePreview(a,b); }
          }
          return;
        }
        if(mode==='liveDash'){
          if(isLast){ if(typeof overlayDashA3==='function') overlayDashA3(pts); else simplePreview(a,b); }
          return;
        }
        if(mode==='liveHatch2'){
          if(isLast){ if(typeof overlayHatchD10==='function') overlayHatchD10(pts); else simplePreview(a,b); }
          return;
        }
        if(mode==='liveHatch'){
          if(typeof overlayDiagHatchRealtimeSegment==='function') overlayDiagHatchRealtimeSegment(a,b); else if(typeof overlayHatchD10==='function') overlayHatchD10(pts); else simplePreview(a,b);
          return;
        }
        if(mode==='liveDots'){
          if(typeof overlayBigDotsRealtimeSegment==='function') overlayBigDotsRealtimeSegment(a,b); else simplePreview(a,b);
          return;
        }

        // ---- finishOnly 系 ----
        if(mode==='finishOnly' && FINISH_PREVIEW_BASES.has(base)){
          simplePreview(a,b);
          return;
        }

        // ---- immediate 系 ----
        switch(base){
          case 'brush.hatchD10min': if(typeof drawHatchD10minSegment==='function') drawHatchD10minSegment(a,b); else stroke(a,b); return;
          case 'brush.vStripesD12': if(typeof drawVerticalStripesD12Segment==='function') drawVerticalStripesD12Segment(a,b); else stroke(a,b); return;
          case 'brush.crossScatterG20': if(typeof drawCrossScatterG20Segment==='function') drawCrossScatterG20Segment(a,b); else stroke(a,b); return;
          case 'brush.randSegG21': if(typeof drawRandSegG21Segment==='function') drawRandSegG21Segment(a,b); else stroke(a,b); return;

          case 'brush.empty': return;
          case 'brush.basicThin': stroke(a,b); return;
          case 'brush.basicJitter2': drawLineJitter(a.x,a.y,b.x,b.y,(currentCfg()?.width.min)||1); return;
          case 'brush.facetA3': if(typeof strokeFaceted==='function') strokeFaceted(a,b); else stroke(a,b); return;
          case 'brush.redDotsC7': if(typeof drawDotSegment==='function') drawDotSegment(a,b); else stroke(a,b); return;
          case 'brush.circlesVarC8': if(typeof drawCirclesVarSegment==='function'){ ctx.save(); resetStrokeState(ctx); ctx.strokeStyle='#000'; drawCirclesVarSegment(a,b); ctx.restore(); } else { stroke(a,b); } return;
          case 'brush.flatD10': if(typeof drawFlat==='function') drawFlat(a,b); else stroke(a,b); return;
          case 'brush.straightE13': stroke(a,b); return;
          case 'brush.sprayBlackF16': if(typeof spraySegment==='function') spraySegment(a,b); else stroke(a,b); return;
          case 'brush.debrisF17': if(typeof drawDebrisSegment==='function') drawDebrisSegment(a,b); else stroke(a,b); return;
          case 'brush.sprinklesF18': if(typeof sprinkleSegment==='function') sprinkleSegment(a,b); else stroke(a,b); return;
          case 'brush.snowSquaresC9': if(typeof drawSnowSquaresSegment==='function') drawSnowSquaresSegment(a,b); else stroke(a,b); return;
          default: stroke(a,b); return;
        }
      } catch(e){ console && console.error && console.error(e); }
    }

    function finish(){
      updateTaglineSizes();
      if(__eraserActive){ drawing=false; pts=[]; return; }

      try{
        if(!pts || pts.length<2){ drawing=false; pts=[]; clearOverlay(); return; }
        const id=currentBrushId(); const base=baseOf(id);
        const mode = modeOf(base);
        if(mode!=='liveBand' && mode!=='liveDots' && mode!=='liveHatch' && mode!=='liveHatch2' && mode!=='liveDash' && FINISH_PREVIEW_BASES.has(base)){
          clearOverlay();
        }

        resetStrokeState(ctx);

        switch(base){
          case 'brush.bandRim':
            if(mode==='liveBand'){ if(typeof bandRimPath==='function') bandRimPath(pts.slice()); else simpleStrokePath(pts, 8); clearOverlay(); }
            break;
          case 'brush.band':
            if(mode==='liveBand'){ if(typeof bandPath==='function') bandPath(pts.slice()); else simpleStrokePath(pts, 10); clearOverlay(); }
            break;
          case 'brush.bandCenter':
            if(mode==='liveBand'){ if(typeof bandPathFillCenter==='function') bandPathFillCenter(pts.slice()); else simpleStrokePath(pts, 10); clearOverlay(); }
            break;
          case 'brush.bigDotsC9':
            if(mode==='liveDots'){
              const cfg=currentCfg(); if(cfg){ const S=cfg._state||{}; const arr=S.bigDotsCenters||[];
                if(arr.length && typeof _commitOffscreen==='function'){
                  const off=document.createElement('canvas'); off.width=cvs.width; off.height=cvs.height;
                  const ox=off.getContext('2d'); ox.setTransform(dpr,0,0,dpr,0,0); resetStrokeState(ox); ox.fillStyle='#000';
                  arr.forEach(c=>{ ox.beginPath(); ox.arc(c.x,c.y,c.R,0,Math.PI*2); ox.fill(); });
                  ox.globalCompositeOperation='destination-out'; arr.forEach(c=>{ ox.beginPath(); ox.arc(c.x,c.y,Math.max(1,c.R-1),0,Math.PI*2); ox.fill(); });
                  _commitOffscreen(off, 0, 0);
                }else{
                  // graceful fallback: draw small dots along the path
                  simpleStrokePath(pts, 2);
                }
                if(S.bigDotsCenters) S.bigDotsCenters=[];
              }
              clearOverlay();
            }
            break;
          case 'brush.diagHatchD11':
            if(mode==='liveHatch'){ if(typeof drawDiagHatchFinishPath==='function') drawDiagHatchFinishPath(pts.slice()); else if(typeof commitHatchD10==='function') commitHatchD10(pts.slice()); else simpleStrokePath(pts,1); clearOverlay(); }
            break;
          case 'brush.dashA3':
            if(mode==='liveDash'){ if(typeof commitDashA3==='function') commitDashA3(pts.slice()); else simpleStrokePath(pts,2); clearOverlay(); }
            break;
          case 'brush.hatchD10min':
            if(mode==='liveHatch2'){ if(typeof commitHatchD10==='function') commitHatchD10(pts.slice()); else simpleStrokePath(pts,1); clearOverlay(); }
            break;
          case 'brush.straightE13': { const a=pts[0], b=pts[pts.length-1]; if(a&&b) stroke(a,b); break; }
          case 'brush.segOutlineD12': { if(typeof segLinesOutlinePath==='function') segLinesOutlinePath(pts.slice()); else simpleStrokePath(pts,2); break; }
          case 'brush.fillGrayB6': { if(typeof fillClosedPath==='function') fillClosedPath(pts.slice(), '#EAEAEA'); else simpleStrokePath(pts, 6); break; }
          default: break;
        }
      } catch(e){ console && console.error && console.error(e); }
      drawing=false; pts=[];
    }

    // D11 overlay（既存）
    function overlayDiagHatchRealtimeSegment(a,b){
      const cfg=currentCfg && currentCfg(); if(!cfg) return;
      ensureBrushState(cfg);
      const dx=b.x-a.x, dy=b.y-a.y; const dist=Math.hypot(dx,dy); if(!(dist>0)) return;
      const dt=(b.t && a.t)? Math.max(1,(b.t-a.t)) : 16;
      const v = dist/(dt/1000);
      const pAvg = ((a.p||0.5)+(b.p||0.5))*0.5;
      const w = Math.max(8, Math.round((cfg.width && cfg.width.min) || 12));
      const basePitch = Math.max(6, Math.round(w*0.9));
      const baseLen   = Math.max(4, Math.round(w*0.8));
      function speedMul(v){ if(!isFinite(v) || v<=0) return 0.95; if(v<400) return 1.00; if(v>1800) return 1.28; return 1.0 + 0.28*(v-400)/1400; }
      function pressureMul(p){ if(!(p>0)) return 1.0; return 1.05 - 0.3*Math.min(1, Math.max(0, (p-0.2)/0.6)); }
      const pitch = basePitch * speedMul(v) * pressureMul(pAvg);
      const ux = dx/dist, uy = dy/dist;
      const nx = -uy, ny = ux;

      const S = (cfg._state = cfg._state || {});
      if (typeof S.hatchResid !== 'number' || S.hatchResid < 0) S.hatchResid = pitch;
      if (typeof S.hatchAlt !== 'number') S.hatchAlt = 0;

      ovctx.save(); resetStrokeState(ovctx);
      ovctx.lineCap='butt'; ovctx.lineJoin='miter';
      ovctx.strokeStyle='#000'; ovctx.lineWidth=1;

      let remain = dist, tLocal=0, resid = S.hatchResid;
      const ang = Math.PI/4; const hx=Math.cos(ang), hy=Math.sin(ang);
      while(remain >= resid){
        tLocal += resid;
        const cx = a.x + ux*tLocal, cy = a.y + uy*tLocal;
        const segLen = baseLen * (0.9 + Math.random()*0.2);
        const sideSign = (S.hatchAlt & 1) ? 1 : -1;
        const offN = sideSign * (w*0.30) * (0.9 + Math.random()*0.2);
        const cxo = cx + nx*offN, cyo = cy + ny*offN;
        const hxv = hx*(segLen/2), hyv = hy*(segLen/2);
        ovctx.beginPath(); ovctx.moveTo(cxo - hxv, cyo - hyv); ovctx.lineTo(cxo + hxv, cyo + hyv); ovctx.stroke();
        S.hatchAlt++; remain -= resid; resid = pitch;
      }
      S.hatchResid = resid - remain;
      ovctx.restore();
    }

    // ストロークの小物（共通）
    function stroke(a,b){ const cfg=currentCfg(); if(!cfg||!a||!b) return; ctx.save(); resetStrokeState(ctx); ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.lineWidth=(cfg.width?.min)||1; ctx.strokeStyle='#000'; ctx.stroke(); ctx.restore(); }
    function drawLineNoAA(x0,y0,x1,y1,ps){
      ctx.save(); resetStrokeState(ctx);
      let xi=Math.round(x0), yi=Math.round(y0), xj=Math.round(x1), yj=Math.round(y1);
      let dx=Math.abs(xj-xi), sx=xi<xj?1:-1, dy=-Math.abs(yj-yi), sy=yi<yj?1:-1, err=dx+dy;
      ctx.fillStyle='#000'; const s=Math.max(1,Math.round(ps||1));
      for(;;){ ctx.fillRect(xi,yi,s,s); if(xi===xj&&yi===yj) break; const e2=2*err; if(e2>=dy){err+=dy; xi+=sx} if(e2<=dx){err+=dx; yi+=sy} }
      ctx.restore();
    }
    function drawLineJitter(x0,y0,x1,y1,ps){
      ctx.save(); resetStrokeState(ctx);
      let xi=Math.round(x0), yi=Math.round(y0), xj=Math.round(x1), yj=Math.round(y1);
      let dx=Math.abs(xj-xi), sx=xi<xj?1:-1, dy=-Math.abs(yj-yi), sy=yi<yj?1:-1, err=dx+dy;
      const s=Math.max(1,Math.round(ps||1)); const J=Math.max(0, Math.floor(s*0.20)); const pj=0.35;
      const horiz = Math.abs(xj-xi) >= Math.abs(yj-yi);
      ctx.fillStyle='#000';
      for(;;){
        let ox=0, oy=0;
        if(J>0 && Math.random()<pj){
          const o=Math.round((Math.random()-Math.random())*J);
          if(horiz){ oy=o; } else { ox=o; }
        }
        ctx.fillRect(xi+ox, yi+oy, s, s);
        if(xi===xj && yi===yj) break;
        const e2=2*err; if(e2>=dy){ err+=dy; xi+=sx; } if(e2<=dx){ err+=dx; yi+=sy; }
      }
      ctx.restore();
    }
    function strokeFaceted(a,b){
      const cfg=currentCfg(); if(!cfg) return;
      const s=Math.max(1,Math.round(cfg.width?.min||1));
      const step=Math.max(2, Math.round(cfg.facetStep || 8));
      const facets=Math.max(3, Math.round(cfg.facets || 12));
      const S=(cfg._state = cfg._state||{}); if(!S.facetPos){ S.facetPos={x:a.x,y:a.y}; }
      let cx=S.facetPos.x, cy=S.facetPos.y;
      const dx=b.x-cx, dy=b.y-cy; const len=Math.hypot(dx,dy); if(!(len>0)) return;
      const ang=Math.atan2(dy,dx); const unit=2*Math.PI/facets; const sector=Math.round(ang/unit); const qAng=sector*unit;
      const ux=Math.cos(qAng), uy=Math.sin(qAng);
      let adv = dx*ux + dy*uy; if(adv<=0){ S.facetPos={x:b.x,y:b.y}; return; }
      while(adv >= step){ const nx = cx + ux*step, ny = cy + uy*step; drawLineNoAA(cx,cy,nx,ny,s); cx = nx; cy = ny; adv -= step; }
      S.facetPos={x:cx,y:cy};
    }
    function drawFlat(a,b){
      const cfg=currentCfg(); if(!cfg) return;
      ctx.save(); resetStrokeState(ctx); ctx.globalCompositeOperation='source-over';
      const wf=Math.max(1, cfg.width?.min || 10);
      const dx=b.x-a.x, dy=b.y-a.y; let len=Math.hypot(dx,dy); if(!(len>0)) len=0.5;
      const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2;
      ctx.translate(cx,cy); ctx.fillStyle='#000'; ctx.fillRect(-len/2, -wf/2, len, wf);
      ctx.restore();
    }
    function drawDotSegment(a,b){
      const cfg=currentCfg(); if(!cfg) return;
      ctx.save(); resetStrokeState(ctx);
      const base=52, pMin=2, pMax=200; 
      const dist=Math.max(1e-4,Math.hypot(b.x-a.x,b.y-a.y));
      const dt=Math.max(1e-4,(b.t-a.t)); const sp=dist/dt, spN=clamp(sp/0.45,0,1);
      const ux=(b.x-a.x)/dist, uy=(b.y-a.y)/dist;
      if(typeof drawDotSegment._ph!=='number') drawDotSegment._ph=0; let ph=drawDotSegment._ph;
      let s0=(base-((drawDotSegment._glob||0)%base));
      while(s0<=dist){
        const cx=a.x+ux*s0, cy=a.y+uy*s0;
        ctx.beginPath(); ctx.arc(cx,cy,Math.max(0.5,cfg.width.min*0.5),0,Math.PI*2); ctx.fillStyle='#000'; ctx.fill();
        const lfo = 0.5 + 0.5*Math.sin(ph*0.18);
        let pitch = base * (0.40 + 0.70*lfo) * (0.85 - 0.40*spN);
        pitch *= 0.75 + 1.0*Math.random(); pitch = clamp(pitch, pMin, pMax);
        s0 += pitch; ph += 1.0;
      }
      drawDotSegment._ph = ph; drawDotSegment._glob=(drawDotSegment._glob||0)+dist;
      ctx.restore();
    }
    function drawCirclesVarSegment(a,b){
      const cfg=currentCfg(); if(!cfg) return;
      ctx.save(); resetStrokeState(ctx);
      const s=cfg.circlesVar||{}; const r=s.bBase||20; const basePitch=s.basePitch||100;
      const gain=(s.speedGainPitch!=null?s.speedGainPitch:0.9), curv=(s.speedCurve!=null?s.speedCurve:1.5), calib=(s.speedCalib!=null?s.speedCalib:1.6);
      const choices=Array.isArray(s.strokeChoices)?s.strokeChoices:[1,4,8,16];
      const dist=Math.max(1e-4,Math.hypot(b.x-a.x,b.y-a.y)); const dt=Math.max(1e-4,(b.t-a.t));
      let spN=Math.max(0,Math.min(1,(dist/dt)/calib)); spN=Math.pow(spN,curv);
      const ux=(b.x-a.x)/dist, uy=(b.y-a.y)/dist; let t=0;
      while(t<=dist){
        const px=Math.round(a.x+ux*t), py=Math.round(a.y+uy*t);
        const sw=choices[Math.floor(Math.random()*choices.length)]||1;
        ctx.lineWidth=sw; ctx.strokeStyle='#000'; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.stroke();
        const pitch=Math.max(14, basePitch*(1+gain*spN))*(1.3+Math.random()*0.7);
        t+=pitch;
      }
      ctx.restore();
    }

    // 入力
    cvs.addEventListener('pointerdown', function(e){
      e.preventDefault(); 
      window.__strokeTick = ((window.__strokeTick|0)+1)|0; resetStrokeState(ctx); resetStrokeState(ovctx);
      if(__eraserActive){
        const now = performance.now();
        if(now - __lastSeatSelectAt < 2500){
          setEraserActive(false);
        }
      }
      drawing=true; pts.length=0;
      clearOverlay();
      const r=cvs.getBoundingClientRect(); const t=performance.now(); const p=(e.pressure>0?e.pressure:0.5);
      pts.push({x:e.clientX-r.left, y:e.clientY-r.top, t, p});
      pushSnapshot();
      __drawIndex=0; __rafPending=false;
      const cfg=currentCfg(); ensureBrushState(cfg);
      if(cfg&&cfg._state){ const S=cfg._state; S.occSnow=new Map(); S.bigDotsCenters=[]; S.snowPhase=0; S.snowDistAcc=0; S.snowTotal=0; S.snowP = 0.4 + Math.random()*0.1; S.bigDotsDist=0; S.spraySide=(Math.random()<0.5?1:-1); S.hatchResid=0; S.hatchAlt=0; if(S.segOut){S.segOut.remain=0;S.segOut.alt=0;S.segOut.acc=0;} }
    });
    cvs.addEventListener('pointermove', function(e){
      if(!drawing) return; const r=cvs.getBoundingClientRect();
      pts.push({x:e.clientX-r.left, y:e.clientY-r.top, t:performance.now(), p:(e.pressure>0?e.pressure:0.5)});
      if(!__rafPending){ __rafPending=true; requestAnimationFrame(__flushDraw); }
    });
    cvs.addEventListener('pointerup', function(){ __flushDraw(); finish(); });
    cvs.addEventListener('pointercancel', function(){ finish(); });

    // サイドボタン
    (function(){
      const eraserBtn=document.getElementById('eraserBtn');
      const backBtn=document.getElementById('backBtn');
      const clearBtn=document.getElementById('clearBtn');
      const saveLink=document.getElementById('saveLink');
      if(eraserBtn) eraserBtn.addEventListener('click', function(){ setEraserActive(!__eraserActive); eraserBtn.classList.add('pressed'); setTimeout(()=>eraserBtn.classList.remove('pressed'),120); });
      if(backBtn)   backBtn.addEventListener('click', function(){ restoreSnapshot(); backBtn.classList.add('pressed'); setTimeout(()=>backBtn.classList.remove('pressed'),120); });
      if(clearBtn)  clearBtn.addEventListener('click', function(){ pushSnapshot(); fillWhite(); clearBtn.classList.add('pressed'); setTimeout(()=>clearBtn.classList.remove('pressed'),120); });
      if(saveLink)  saveLink.addEventListener('click', function(){
        try{
          
          // Composite current canvas onto an offscreen white canvas to ensure white background in PNG
          const out=document.createElement('canvas');
          out.width=cvs.width; out.height=cvs.height;
          const g=out.getContext('2d');
          g.setTransform(1,0,0,1,0,0);
          g.fillStyle='#fff'; g.fillRect(0,0,out.width,out.height);
          g.drawImage(cvs,0,0);
          const url=out.toDataURL('image/png');
          const a=document.createElement('a');
          const now=new Date();
          const ts=[now.getFullYear(), ('0'+(now.getMonth()+1)).slice(-2), ('0'+now.getDate()).slice(-2), '_', ('0'+now.getHours()).slice(-2), ('0'+now.getMinutes()).slice(-2), ('0'+now.getSeconds()).slice(-2)].join('');
          a.download='doodle-line_'+ts+'.png';
          a.href=url;
          document.body.appendChild(a);
          a.click();
          setTimeout(()=>document.body.removeChild(a), 150);
        }catch(e){ console.error('PNG save failed:', e); }
      });
      updateBackEnabled();
    })();

    // Init
    buildThumbs(); layoutThumbbar(); updateTaglineSizes();
  });
  </script>
</body>
</html>